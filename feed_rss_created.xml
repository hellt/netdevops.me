<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>Applying DevOps to networks</title><description>Applying DevOps to networks.</description><link>https://netdevops.me/</link><atom:link href="https://netdevops.me/feed_rss_created.xml" rel="self" type="application/rss+xml" /><managingEditor>Roman Dodin</managingEditor><docs>https://github.com/hellt/netdevops.me</docs><language>en</language> <pubDate>Thu, 13 Oct 2022 11:22:33 -0000</pubDate> <lastBuildDate>Thu, 13 Oct 2022 11:22:33 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.5.0</generator> <item> <title>gNMIc joins Openconfig üöÄ</title> <author>rdodin</author> <category>gnmi</category> <category>gnmic</category> <category>openconfig</category> <description>&lt;h1&gt;gNMIc joins Openconfig üöÄ&lt;/h1&gt;&lt;p&gt;Two years ago, a dozen contributors less, 400 Pull Requests, and 2000 commits behind, another pet project appeared on a vast GitHub landscape. It was a learning exercise by [Karim Radhouani][karim-github] to sharpen his skills in [gNMI][gnmi-ref] - a niche network management protocol promoted by the [Openconfig][oc] group.&lt;/p&gt;&lt;p&gt;Initially named &lt;code&gt;gnmi_client&lt;/code&gt;, it had a noble but narrow scope of providing a feature-rich, complete, yet intuitive CLI for gNMI-enabled routers. Fast forward two years, and we have the [&lt;strong&gt;gNMIc&lt;/strong&gt;][gnmic-main-site] software suite that &lt;strong&gt;is much more than just a CLI&lt;/strong&gt; for gNMI.&lt;/p&gt;&lt;div class=&#34;img-shadow&#34;&gt;&lt;video width=&#34;100%&#34; autoplay muted loop controls&gt;&lt;source src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/d3a08c2f03c2d15db2074967e4ef268f/gnmic-oc.mp4&#34; type=&#34;video/mp4&#34;&gt;&lt;/video&gt;&lt;/div&gt;&lt;p&gt;Today, Nokia donates the gNMIc project to Openconfig, and with that move, we expect to see gNMIc adopted by even more companies and organizations :partying_face:&lt;/p&gt;&lt;div class=&#34;grid cards&#34; markdown&gt;- :material-home:{ .lg .middle } **gNMIc new address** --- :material-github: [openconfig/gnmic][gnmic-repo] :material-book: [https://gnmic.openconfig.net][gnmic-main-site]&lt;/div&gt;&lt;p&gt;In this post I&#39;d like to give you a brief overview of gNMIc&#39;s core features and share my thoughts on what we expect to happen with gNMIc moving under the Openconfig&#39;s wing.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;Over the past two years, gNMIc became a feature-rich gNMI-focused software suite. Both its CLI and collection capabilities matured with lots of new integrations added. Moreover, gNMIc had quite some air time in production networks, not to mention lab deployments and dev testbeds.&lt;/p&gt;&lt;p&gt;I would like to briefly highlight gNMIc&#39;s current feature set for those who aren&#39;t familiar with it yet. Broadly, we split gNMIc capabilities into the following three domains:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;CLI&lt;/li&gt;&lt;li&gt;Collector&lt;/li&gt;&lt;li&gt;API&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;!!!note Each of those domain areas packs a hefty number of neat features, and I will only highlight some of them to keep the introduction short and sweet.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;gNMIc cherishes documentation; readers are encouraged to follow the links provided in this post to get more information on particular topics.&lt;/code&gt;&lt;/pre&gt;&lt;p markdown align=center&gt;![logo](https://gitlab.com/rdodin/pics/-/wikis/uploads/46e7d1631bd5569e9bf289be9dfa3812/gnmic-headline.svg?sanitize=true#only-light)![logo](https://gitlab.com/rdodin/pics/-/wikis/uploads/f54d2cfdde13193cedab7b60203a2a9a/gnmic-headline-for-dark-bg.svg?sanitize=true#only-dark)&lt;/p&gt;&lt;h2&gt;CLI&lt;/h2&gt;&lt;p&gt;gNMIc provides an intuitive yet full-featured CLI for interacting with gNMI-capable targets. It fully implements [gNMI v0.7+ specification][gnmi-ref] with extensions[^1], and with the move under Openconfig, it becomes a standard gNMI CLI tool.&lt;/p&gt;&lt;p&gt;In 2020 I &lt;a href=&#34;../2020/gnmic.md&#34;&gt;wrote about gNMIc&lt;/a&gt; highlighting its CLI capabilities. Since then CLI side of gNMIc has only become better with the following changes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Added [template-based payloads][template-set] to simplify complex and data-driven configuration use cases.&lt;/li&gt;&lt;li&gt;[GetSet command][getset-cmd] introduced to allow conditional execution of a Set RPC based on a received Get response.&lt;/li&gt;&lt;li&gt;Implemented [&lt;code&gt;diff&lt;/code&gt; command][diff-cmd] to compare configurations between two different targets and identify configuration drift.&lt;/li&gt;&lt;li&gt;Added [&lt;code&gt;prompt&lt;/code&gt; mode][prompt-cmd] for a guided CLI experience.&lt;/li&gt;&lt;li&gt;Added [generation of paths][path-gen] out of the YANG modules.&lt;/li&gt;&lt;li&gt;Support configuration via any of the following methods: CLI flags, environment variables, or file.&lt;/li&gt;&lt;li&gt;Integrated prototext and protojson output options to display raw requests and responses.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;!!!tip &#34;gNMIc CLI&#34; Easy one-click installation, multi-arch/multi-OS hermetic binary, full feature parity with gNMI spec and intuitive commands layout make &lt;code&gt;gnmic&lt;/code&gt; tool a perfect choice for the task.&lt;/p&gt;&lt;div class=&#34;ext-code-divider&#34;&gt;&lt;hr /&gt;&lt;span class=&#34;twemoji vertical-middle&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 640 512&#34;&gt;&lt;path d=&#34;M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3L562.7 256l-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z&#34;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;hr /&gt;&lt;/div&gt;&lt;h2&gt;Collector&lt;/h2&gt;&lt;p&gt;Having a great CLI was just the beginning; the lion&#39;s share of changes happened in the collector area of gNMIc.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;collector&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/9f535d6b64cc5794d995104e37a8c04a/image.png&#34;&gt;{: class=&#34;img-shadow&#34;}&lt;br&gt;&lt;center&gt;&lt;small&gt;gNMIc as a collector in a typical open-source streaming telemetry deployment&lt;/small&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;With the growing interest in Streaming Telemetry, we saw an opportunity to create an open-source telemetry collector to meet the demand. Not just &lt;em&gt;a collector&lt;/em&gt;...&lt;/p&gt;</description><link>https://netdevops.me/2022/gnmic-joins-openconfig/</link> <pubDate>Tue, 04 Oct 2022 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2022/gnmic-joins-openconfig/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2022/gnmic-joins-openconfig/</guid> </item> <item> <title>Using guestfish container image</title> <author>rdodin</author> <category>guestfish</category> <description>&lt;h1&gt;Using guestfish container image&lt;/h1&gt;&lt;p&gt;Once in a while, one still needs to get down to a VM-land and dust off some guestfish skills.&lt;/p&gt;&lt;p&gt;Like today I got the IPInfusion OcNOS &lt;code&gt;qcow2&lt;/code&gt; image whose devs decided it is best to use VNC console by default. VNC console for a text-based terminal...&lt;/p&gt;&lt;p&gt;So along come guestfish commands.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;It is hugely satisfying to modify the VM images using containers, so here are my two commands to modify GRUB settings.&lt;/p&gt;&lt;p&gt;I first check the initial grub content, then swap it with a modified one (with a serial console, right?). Clean, fast, üßë‚Äçüç≥&lt;/p&gt;&lt;p&gt;```bash&lt;/p&gt;&lt;h1&gt;show image&#39;s file contents&lt;/h1&gt;&lt;p&gt;DISK_IMG=/tmp/ocnos.qcow2DISK_DIR=$(dirname ${DISK_IMG})DISK_NAME=$(basename ${DISK_IMG})&lt;/p&gt;&lt;p&gt;docker run -i --rm \ -v ${DISK_DIR}:/work/${DISK_DIR} \ -w /work/${DISK_DIR} \ bkahlert/libguestfs \ guestfish \ --ro \ --add ${DISK_NAME} \ --mount /dev/sda1:/ \ cat /etc/default/grub```&lt;/p&gt;&lt;p&gt;```bash&lt;/p&gt;&lt;h1&gt;copy-in a file&lt;/h1&gt;&lt;p&gt;LOCAL_FPATH=/tmp/ocnos-newgrubREMOTE_FPATH=/etc/default/grub&lt;/p&gt;&lt;p&gt;docker run -i --rm \ -v ${DISK_DIR}:/work/${DISK_DIR} \ -v ${LOCAL_FPATH}:/work${LOCAL_FPATH} \ -w /work/${DISK_DIR} \ bkahlert/libguestfs \ guestfish \ --rw \ --add ${DISK_NAME} \ --mount /dev/sda1:/ \ upload /work${LOCAL_FPATH} ${REMOTE_FPATH}```&lt;/p&gt;</description><link>https://netdevops.me/2022/using-guestfish-container-image/</link> <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2022/using-guestfish-container-image/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2022/using-guestfish-container-image/</guid> </item> <item> <title>DIY YANG Browser</title> <author>rdodin</author> <category>netrel</category> <category>yang</category> <description>&lt;h1&gt;DIY YANG Browser&lt;/h1&gt;&lt;p&gt;Here comes the second episode of the NetRel show: &lt;strong&gt;NetRel episode 002 - DIY YANG Browser&lt;/strong&gt;. Be ready to dive into the paths we took to create a &lt;a href=&#34;https://yang.srlinux.dev&#34;&gt;YANG Browser for Nokia SR Linux platform&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;/p&gt;&lt;iframe type=&#34;text/html&#34; width=&#34;80%&#34; height=&#34;465&#34; src=&#34;https://www.youtube.com/embed/_d4hL7I2h1w&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;&lt;p&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;YANG data models are the map one should use when looking for their way to configure or retrieve any data on SR Linux system. A central role that is given to YANG in SR Linux demands a convenient interface to browse, search through, and process these data models.&lt;/p&gt;&lt;p&gt;To answer these demands, we created a web portal - &lt;a href=&#34;https://yang.srlinux.dev&#34;&gt;https://yang.srlinux.dev&lt;/a&gt; - it offers:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Fast Path Browser to effectively search through thousands of available YANG paths&lt;/li&gt;&lt;li&gt;Beautiful Tree Browser to navigate the tree representation of the entire YANG data model of SR Linux&lt;/li&gt;&lt;li&gt;Source &lt;code&gt;.yang&lt;/code&gt; files neatly stored in nokia/srlinux-yang-models repository for programmatic access and code generation&lt;/li&gt;&lt;/ul&gt;</description><link>https://netdevops.me/2022/diy-yang-browser/</link> <pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2022/diy-yang-browser/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2022/diy-yang-browser/</guid> </item> <item> <title>Decoding gNMI with Wireshark</title> <author>rdodin</author> <category>gnmi</category> <category>gnmic</category> <category>netrel</category> <description>&lt;h1&gt;Decoding gNMI with Wireshark&lt;/h1&gt;&lt;p&gt;Okay, here goes my first attempt fitting the shoes of a content creator.&lt;/p&gt;&lt;p&gt;Please welcome the &lt;strong&gt;NetRel episode 001 - Decoding gNMI with Wireshark&lt;/strong&gt;, it is a 35min journey of using Wireshark to parse the gNMI traffic (both non-secured and secured).&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;/p&gt;&lt;iframe type=&#34;text/html&#34; width=&#34;80%&#34; height=&#34;465&#34; src=&#34;https://www.youtube.com/embed/gRqBMTRKDfE&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;&lt;p&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;I won&#39;t spend your time explaining the first episode; instead, let me tell you what I want the NetRel series to be about. I am interested in covering the aspects of network automation that are not widely covered.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;Luckily, my main line of work often offers me chances to work with the technologies relevant for webscalers. Hence, I will focus on the advanced content and not waste effort on the beginners&#39; videos. A few broad topics that I wish to cover along the way:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Go for network automation&lt;/li&gt;&lt;li&gt;YANG based automation and programmable interfaces&lt;/li&gt;&lt;li&gt;k8s as a network control plane&lt;/li&gt;&lt;li&gt;gNxI interfaces&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Quite convinced a few more topics will stem in time, but these are the current candidates.&lt;/p&gt;&lt;p&gt;Now a few words on why YT? Why now?&lt;/p&gt;&lt;p&gt;1.5 years ago I was willing to die on the hill of the text-based blogs. I do still love blogs and think they offer the best signal/noise ratio for knowledge transfer. But over time, I noticed how video blogs become dominant. I realized that I land on YT more often than stumble upon a text blog. So, as a viewer, I see how video material is getting ahead in terms of audience coverage and views.&lt;/p&gt;&lt;p&gt;The video genre also makes it easier to add interactivity to your content. Gifs &amp;amp; screenshots can&#39;t compete with a hands-on demo you can record with a voice-over. This was the second plus on the blogs-v-videos scales that inclined me to try out going solo on YT.&lt;/p&gt;&lt;p&gt;As far as content creation goes, in my case, the time required to create a video is &amp;gt; time needed to craft a blog post. But I can see how this can improve over time. The more you get used to the editing process and grow your library of intros/callouts/etc, the easier it gets. What helped me overstep the barrier of spending too much time in editing is making a contract with myself. If I stutter, misspel a word or make a grammar mistake I roll with it. Minimum cuts, maximum time to work on the content itself and not its form.&lt;/p&gt;</description><link>https://netdevops.me/2022/decoding-gnmi-with-wireshark/</link> <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2022/decoding-gnmi-with-wireshark/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2022/decoding-gnmi-with-wireshark/</guid> </item> <item> <title>Using scrapligo with kubectl exec</title> <author>rdodin</author> <category>docker</category> <category>go</category> <category>kubernetes</category> <category>scrapli</category> <description>&lt;h1&gt;Using scrapligo with kubectl exec&lt;/h1&gt;&lt;script type=&#34;text/javascript&#34; src=&#34;https://viewer.diagrams.net/js/viewer-static.min.js&#34; async&gt;&lt;/script&gt;&lt;p&gt;As the networking industry is (slowly) moving towards forklifting networking functions to the cloud-native space we often become the witnesses of mixing decade old tools with cloud-native approaches and architectures.&lt;/p&gt;&lt;p&gt;This post is about one such crazy mixture of using screen scraping library &lt;a href=&#34;https://github.com/scrapli/scrapligo&#34;&gt;scrapligo&lt;/a&gt; with &lt;code&gt;kubectl exec&lt;/code&gt; and &lt;code&gt;docker exec&lt;/code&gt; commands.&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;What and Why?&lt;/h2&gt;&lt;p&gt;I can imagine that for some readers the previous sentence makes no sense, why do you need a screen scraping library when working with standalone containers or kubernetes workloads? Shouldn&#39;t it be all covered with various APIs already?&lt;/p&gt;&lt;p&gt;It should, yes, but when networking workloads are being moved into &lt;em&gt;the cloud&lt;/em&gt; it is more often than not results in a compromised architecture which is not fully aligned with the behavior of the containerized workloads.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;For example, when deploying a network function on kubernetes you might realize that the container image doesn&#39;t use the IP address that container runtime provisions for its &lt;code&gt;eth0&lt;/code&gt; interface.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Or you might want to add some basic configuration to a Network OS running as a k8s pod without creating a service for its SSH/NETCONF/etc server.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Or you need to generate self-signed certificates on the NOS side to enable programmable access via gNMI or HTTPS.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In all these cases you often resort to &lt;code&gt;kubectl/docker exec&lt;/code&gt; commands to connect to a shell/CLI and do some CLI based configuration over that terminal interface. This makes &lt;code&gt;kubectl exec&lt;/code&gt; pretty much a modern day Telnet.&lt;/p&gt;&lt;p&gt;Since these operations over a terminal interface allocated by &lt;code&gt;exec&lt;/code&gt; commands are almost inevitable, it makes a lot of sense to be able to automate interactions over it.&lt;/p&gt;&lt;h2&gt;scrapligo and &lt;code&gt;kubectl exec&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;Scrapligo, which is a &lt;a href=&#34;https://netdevops.me/2021/network-automation-options-in-go-with-scrapligo/&#34;&gt;Go version of the famous Scrapli library&lt;/a&gt;, is now able to handle CLI based interactions over the terminal interface offered by &lt;code&gt;docker exec&lt;/code&gt; or &lt;code&gt;kubectl exec&lt;/code&gt; (or any other command that exposes a PTY actually).&lt;/p&gt;&lt;div class=&#34;mxgraph&#34; style=&#34;max-width:100%;border:1px solid transparent;margin:0 auto; display:block;&#34; data-mxgraph=&#34;{&amp;quot;page&amp;quot;:0,&amp;quot;zoom&amp;quot;:2,&amp;quot;highlight&amp;quot;:&amp;quot;#0000ff&amp;quot;,&amp;quot;nav&amp;quot;:true,&amp;quot;check-visible-state&amp;quot;:true,&amp;quot;resize&amp;quot;:true,&amp;quot;url&amp;quot;:&amp;quot;https://raw.githubusercontent.com/hellt/diagrams.net/master/scrapligo-exec.drawio&amp;quot;}&#34;&gt;&lt;/div&gt;&lt;p&gt;This is especially cool in conjunction with &lt;code&gt;kubectl exec&lt;/code&gt;, since you might have your networking workloads live in a remote cluster and without any k8s services you could get programmatic access to the shell/CLI of the Network OS to perform some bootstrap or validation.&lt;/p&gt;&lt;p&gt;An approach like that can hugely simplify the operations of networking workloads in the remote clusters, and believe me, the tasks that you can&#39;t carry out otherwise still exist...&lt;/p&gt;&lt;h2&gt;Lab deployment&lt;/h2&gt;&lt;p&gt;To demonstrate this new scrapligo capability I will use the following user story.&lt;/p&gt;&lt;p&gt;A user deployed a networking lab with Nokia SR Linux nodes on a remote k8s cluster. They intend to manage the nodes with gNMI interface, but in order to do that, a TLS certificate must be provisioned on a device which gNMI will use to secure the transport layer.&lt;/p&gt;&lt;div class=&#34;mxgraph&#34; style=&#34;max-width:100%;border:1px solid transparent;margin:0 auto; display:block;&#34; data-mxgraph=&#34;{&amp;quot;page&amp;quot;:1,&amp;quot;zoom&amp;quot;:3,&amp;quot;highlight&amp;quot;:&amp;quot;#0000ff&amp;quot;,&amp;quot;nav&amp;quot;:true,&amp;quot;check-visible-state&amp;quot;:true,&amp;quot;resize&amp;quot;:true,&amp;quot;url&amp;quot;:&amp;quot;https://raw.githubusercontent.com/hellt/diagrams.net/master/scrapligo-exec.drawio&amp;quot;}&#34;&gt;&lt;/div&gt;&lt;p&gt;!!!info I am using SR Linux containers here because they are &lt;a href=&#34;https://netdevops.me/2021/nokia-sr-linux-goes-public/&#34;&gt;available for pulling for everyone&lt;/a&gt;, but you can swap it with Arista cEOS or any other NOS easily.&lt;/p&gt;&lt;p&gt;For various reasons, it is not possible to configure an Ingress service to enable external access for SR Linux workload, but cluster management is possible via &lt;code&gt;kubectl&lt;/code&gt;. So we could configure TLS certificates over &lt;code&gt;kubectl exec&lt;/code&gt;, and that is what we will do, but programmatically.&lt;/p&gt;&lt;p&gt;To replicate this scenario we will deploy two docker containers on a host&lt;/p&gt;&lt;ul&gt;&lt;li&gt;the container named &lt;code&gt;gnmi&lt;/code&gt; that hosts the &lt;a href=&#34;https://gnmic.kmrd.dev&#34;&gt;&lt;code&gt;gnmic&lt;/code&gt;&lt;/a&gt; tool to test gNMI access&lt;/li&gt;&lt;li&gt;and &lt;code&gt;srlinux&lt;/code&gt; container that is our Network OS of choice.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;On the docker host side we will run a &lt;a href=&#34;https://github.com/hellt/scrapligo-pty-demo&#34;&gt;&lt;code&gt;scrapligo&lt;/code&gt; program&lt;/a&gt; that will provision TLS certificates and gNMI service over &lt;code&gt;docker exec&lt;/code&gt; command (step 1).&lt;/p&gt;&lt;p&gt;Then container with &lt;code&gt;gnmic&lt;/code&gt; inside will be able to use gNMI service on the srlinux container (step 2).&lt;/p&gt;&lt;p&gt;!!!info For simplicity we use &lt;code&gt;docker exec&lt;/code&gt; and plain containers, but the same will work with `kubectl ex...&lt;/p&gt;</description><link>https://netdevops.me/2021/using-scrapligo-with-kubectl-exec/</link> <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2021/using-scrapligo-with-kubectl-exec/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2021/using-scrapligo-with-kubectl-exec/</guid> </item> <item> <title>Nokia SR Linux goes public</title> <author>rdodin</author> <category>containerlab</category> <category>nokia</category> <category>srlinux</category> <description>&lt;h1&gt;Nokia SR Linux goes public&lt;/h1&gt;&lt;p&gt;It&#39;s been almost two years since Nokia announced its &lt;a href=&#34;https://www.nokia.com/networks/solutions/data-center-switching-fabric/&#34;&gt;Data Center Fabric solution&lt;/a&gt;. The three-layered solution ranged from hardware platforms all the way up in the stack to the DC fabric lifecycle management suite - &lt;a href=&#34;https://www.nokia.com/networks/products/fabric-services-system/&#34;&gt;Fabric Services System (FSS)&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;pic1&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/25f1ebe301b17296975c165fc2889d2a/image.png&#34;&gt;&lt;/p&gt;&lt;p&gt;At the very heart of the DC Fabric solution lies a purpose-built, modern Network OS - &lt;a href=&#34;https://www.nokia.com/networks/products/service-router-linux-NOS/&#34;&gt;SR Linux&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/96e2a0b880aede62dbaf1152608d6119/image.png&#34;&gt;&lt;img alt=&#34;pic2&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/96e2a0b880aede62dbaf1152608d6119/image.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;SR Linux comes with quite some interesting and innovative ideas. By being able to design the NOS from the ground up, the product team was freed from the legacy burdens which will be there have they decided to built the NOS on top of the existing one. Features like:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;YANG-first APIs&lt;/li&gt;&lt;li&gt;Protobuf based SDK&lt;/li&gt;&lt;li&gt;Disaggregated application stack&lt;/li&gt;&lt;li&gt;Programmable CLI&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;are the result of taking a fresh look at the modern data center networks and building the NOS for the Netdevops era.&lt;/p&gt;&lt;p&gt;No wonders engineers around the world wanted to play with SR Linux and take those features for a spin first hand. And today it is finally possible!&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;Public SR Linux container&lt;/h2&gt;&lt;p&gt;I am a firm believer that Network Operating Systems should be available for testing to everybody. The reality, unfortunately, is quite different, with vendors either not allowing you to download virtual NOS at all, or requiring you to have an account, a registration with their system or a license file to run it.&lt;/p&gt;&lt;p&gt;With SR Linux, we are making a big step into the openness by pushing SR Linux container to the &lt;a href=&#34;https://github.com/orgs/nokia/packages/container/package/srlinux&#34;&gt;public container registry&lt;/a&gt; so everyone can it pull without any registration, payments, or active service accounts. Absolutely free and open.&lt;/p&gt;&lt;p&gt;&lt;code&gt;bashdocker pull ghcr.io/nokia/srlinux&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;Running light&lt;/h3&gt;&lt;p&gt;Containerized NOSes have a lot of benefits that come from the container packaging. One of them being lightweight compared to the VM-based counterparts.&lt;/p&gt;&lt;p&gt;On average, a single SR Linux container will consume about 0.5vCPU and ~1GB RAM[^2]. That allows you to spin up labs of decent size having only an entry-level VM at your disposal.&lt;/p&gt;&lt;p&gt;For example, one of the most typical labs is a Clos fabric with a few leafs and spines. The lab like that will fit into 2vCPU and 6GB RAM VM.&lt;/p&gt;&lt;div class=&#34;mxgraph&#34; style=&#34;max-width:100%;border:1px solid transparent;margin:0 auto; display:block;&#34; data-mxgraph=&#34;{&amp;quot;page&amp;quot;:15,&amp;quot;zoom&amp;quot;:1.5,&amp;quot;highlight&amp;quot;:&amp;quot;#0000ff&amp;quot;,&amp;quot;nav&amp;quot;:true,&amp;quot;check-visible-state&amp;quot;:true,&amp;quot;resize&amp;quot;:true,&amp;quot;url&amp;quot;:&amp;quot;https://raw.githubusercontent.com/srl-wim/container-lab/diagrams/containerlab.drawio&amp;quot;}&#34;&gt;&lt;/div&gt;&lt;p&gt;You can even run this lab on a free Github Actions runner, which has 8GB RAM. Imagine the sheer possibilities in writing CI pipelines for testing your DC features which can run in the public cloud for free.&lt;/p&gt;&lt;h3&gt;Full feature parity&lt;/h3&gt;&lt;p&gt;When working with virtual networking products one needs to be aware of any limitations the virtual appliance imposes. Quite often the virtual images we work with in labs are crippled both in dataplane and control plane functions.&lt;/p&gt;&lt;p&gt;These limitations of the virtual images make it hard to create a reliable and &#34;real&#34; automated testing pipeline.&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;When you say vNOS, do you mean as a separate standalone product or as a virtual version of an image that will be sold to run on hardware only?&lt;/p&gt;&amp;mdash; Joe Neville üåª (@joeneville_) &lt;a href=&#34;https://twitter.com/joeneville_/status/1417855086076760066?ref_src=twsrc%5Etfw&#34;&gt;July 21, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;SR Linux container has the same code inside that actually runs on our hardware platforms. There is no control or data plane deviations[^1], so by using this image in your CI pipelines you can be sure that when deployed to production, it will behave the same.&lt;/p&gt;&lt;p&gt;And all that with a small resource footprint. Imagine running a fully functional 3-stage mini-Clos fabric with 6 nodes on a machine with 2vCPU and 6GB RAM? That will fit into a free GitHub runner!&lt;/p&gt;&lt;h3&gt;No license strings attached&lt;/h3&gt;&lt;p&gt;Being able to pull SR Linux NOS as any other container image is big on its own, but we also wanted to make sure that you can use right away. To do that, we made licensing optional, so once you pulled an image you can use it to its full extent!&lt;/p&gt;&lt;p&gt;!!!info When running without a license users can enjoy all the features of SR Linux, but dataplane i...&lt;/p&gt;</description><link>https://netdevops.me/2021/nokia-sr-linux-goes-public/</link> <pubDate>Wed, 21 Jul 2021 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2021/nokia-sr-linux-goes-public/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2021/nokia-sr-linux-goes-public/</guid> </item> <item> <title>Network automation options in Go with scrapligo</title> <author>rdodin</author> <category>netconf</category> <category>scrapli</category> <category>textfsm</category> <description>&lt;h1&gt;Network automation options in Go with scrapligo&lt;/h1&gt;&lt;p&gt;Just recently the network automation folks witnessed a great library to be ported from Python to Go - &lt;a href=&#34;https://github.com/scrapli/scrapligo&#34;&gt;scrapligo&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Been working on learning go a bit and have published scrapligo &lt;a href=&#34;https://t.co/NDXQ6khxCr&#34;&gt;https://t.co/NDXQ6khxCr&lt;/a&gt; -- still a work in progress, but has been a fun learning experience! Check it out and let me know what ya think! ü§†&lt;/p&gt;&amp;mdash; Carl Montanari (@carlrmontanari) &lt;a href=&#34;https://twitter.com/carlrmontanari/status/1395048837656367105?ref_src=twsrc%5Etfw&#34;&gt;May 19, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;For me personally this was a pivotal point because with scrapligo the Go-minded netengs can now automate their networks with a solid and performant library.&lt;/p&gt;&lt;p&gt;One of the things that scrapligo packs is, of course, the ability to reliably &lt;em&gt;talk&lt;/em&gt; to the network devices using the same command line interface as a human would normally do. That means that scrapligo would send and receive the pieces of data that an operator would send/receive if they were connected with a terminal over SSH.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;As you may very well be aware, the typical output that a network device produces for a given command is unstructured, meaning that it is not presented in a way that can be &lt;em&gt;effortlessly&lt;/em&gt; parsed by a machine.&lt;/p&gt;&lt;p&gt;```bash&lt;/p&gt;&lt;h1&gt;output of a &lt;code&gt;show system information&lt;/code&gt; command from Nokia SR OS&lt;/h1&gt;&lt;p&gt;===============================================================================System Information===============================================================================System Name : srosSystem Type : 7750 SR-1Chassis Topology : StandaloneSystem Version : B-20.10.R3Crypto Module Version : SRCM 3.1System Contact :System Location :System Coordinates :System Up Time : 8 days, 00:24:27.04 (hr:min:sec)```&lt;/p&gt;&lt;p&gt;If we were to send &lt;code&gt;show system information&lt;/code&gt; command with scrapligo towards a Nokia SR OS device, we would have not be able to get, say, the device version right away, since the response is basically the unstructured blob of text as the program sees it.&lt;/p&gt;&lt;p&gt;What can we do about it?&lt;/p&gt;&lt;h2&gt;use NETCONF/gNMI/API&lt;/h2&gt;&lt;p&gt;In an ideal world, you would have stopped reading this post, because ALL your devices were equipped with some kind of programmatic interface that returns structured data. Like in the example above we connect to the SR OS node with scrapligo netconf subsystem and retrieve back a result of a NETCONF Get operation.&lt;/p&gt;&lt;p&gt;We then can run a query on this XML document we received and get the data out just nicely.&lt;/p&gt;&lt;p&gt;```gopackage main&lt;/p&gt;&lt;p&gt;import ( &#34;fmt&#34; &#34;strings&#34;&lt;/p&gt;&lt;p&gt;&#34;github.com/antchfx/xmlquery&#34; &#34;github.com/scrapli/scrapligo/driver/base&#34; &#34;github.com/scrapli/scrapligo/netconf&#34; &#34;github.com/scrapli/scrapligo/transport&#34;)&lt;/p&gt;&lt;p&gt;func main() { d, _ := netconf.NewNetconfDriver( &#34;clab-scrapli-sros&#34;, base.WithAuthStrictKey(false), base.WithAuthUsername(&#34;admin&#34;), base.WithAuthPassword(&#34;admin&#34;), base.WithTransportType(transport.StandardTransportName), )&lt;/p&gt;&lt;p&gt;d.Open()&lt;/p&gt;&lt;p&gt;r, _ := d.Get(netconf.WithNetconfFilter(&lt;code&gt;&amp;lt;state xmlns=&#34;urn:nokia.com:sros:ns:yang:sr:state&#34;&amp;gt; &amp;lt;system&amp;gt;&amp;lt;version&amp;gt;&amp;lt;version-number/&amp;gt;&amp;lt;/version&amp;gt;&amp;lt;/system&amp;gt; &amp;lt;/state&amp;gt;&lt;/code&gt;))&lt;/p&gt;&lt;p&gt;doc, _ := xmlquery.Parse(strings.NewReader(r.Result))&lt;/p&gt;&lt;p&gt;ver := xmlquery.Find(doc, &#34;//version-number&#34;)&lt;/p&gt;&lt;p&gt;fmt.Println(ver[0].InnerText())&lt;/p&gt;&lt;p&gt;d.Close()}```&lt;/p&gt;&lt;p&gt;Output:&lt;/p&gt;&lt;p&gt;&lt;code&gt;‚ùØ go run netconf.goB-20.10.R3&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Unfortunately we are not yet there, we have thousands of access devices in Service Providers network which do not have any of the fancy interface. We have Enterprise networks running decade old gear. And we also live in a harsh world where even if the Network OS has one of those fancy interface, the level of information you can query via them is &lt;strong&gt;not on par with what you can do over CLI&lt;/strong&gt;.&lt;/p&gt;&lt;h2&gt;on-box JSON output&lt;/h2&gt;&lt;p&gt;The next best thing is to leverage the device&#39;s ability to present the output as JSON. Then you can capture this output over SSH and let your JSON parser to do it&#39;s thing.&lt;/p&gt;&lt;p&gt;For example, on EOS every show command can be represented as a JSON blob:&lt;/p&gt;&lt;p&gt;&lt;code&gt;jsonceos&amp;gt;show inventory | json{ &#34;fpgas&#34;: {}, &#34;storageDevices&#34;: {}, &#34;xcvrSlots&#34;: {}, &#34;subcompSerNums&#34;: {}, &#34;portCount&#34;: 3, &#34;switchedBootstrapPortCount&#34;: 2, &#34;managementPortCount&#34;: 1, &#34;dataLinkPortCount&#34;: 0, &#34;emmcFlashDevices&#34;: {}, &#34;cardSlots&#34;: {}, &#34;internalPortCount&#34;: 0, &#34;powerSupplySlots&#34;: {}, &#34;fanTraySlots&#34;: {}, &#34;systemInformation&#34;: { &#34;name&#34;: &#34;cEOSLab&#34;, &#34;description&#34;: &#34;cEOSLab&#34;, &#34;mfgDate&#34;: &#34;&#34;, &#34;hardwareRev&#34;: &#34;&#34;, &#34;hwEpoch&#34;: &#34;&#34;, &#34;serialNum&#34;: &#34;&#34; }, &#34;unconnectedPortCount&#34;: 0, &#34;switchedPortCount&#34;: 0, &#34;switchedFortyGOnlyPortCount&#34;: 0}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;and with this tiny &lt;code&gt;scrapligo&lt;/code&gt; program you can easily retrieve all the data from ...&lt;/p&gt;</description><link>https://netdevops.me/2021/network-automation-options-in-go-with-scrapligo/</link> <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2021/network-automation-options-in-go-with-scrapligo/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2021/network-automation-options-in-go-with-scrapligo/</guid> </item> <item> <title>Containerlab - your network-centric labs with a Docker UX</title> <author>rdodin</author> <category>arista</category> <category>ceos</category> <category>cisco</category> <category>containerlab</category> <category>crpd</category> <category>frr</category> <category>juniper</category> <category>nokia</category> <category>sonic</category> <category>srlinux</category> <description>&lt;h1&gt;Containerlab - your network-centric labs with a Docker UX&lt;/h1&gt;&lt;p&gt;With the growing number of containerized Network Operating Systems (NOS) grows the demand to easily run them in the user-defined, versatile lab topologies. Unfortunately, container runtimes alone and tools like docker-compose are not a particularly good fit for that purpose, as they do not allow a user to easily create p2p connections between the containers.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;https://containerlab.srlinux.dev&#34;&gt;Containerlab&lt;/a&gt; provides a framework for orchestrating networking labs with containers. It starts the containers, builds a virtual wiring between them to create a topology of users choice and then manages a lab lifecycle.&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/xdi7rwdJgkg&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;Containerlab focuses on containerized Network Operating Systems such as:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://www.nokia.com/networks/products/service-router-linux-NOS/&#34;&gt;Nokia SR-Linux&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Arista cEOS&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://sonic-net.github.io/SONiC/&#34;&gt;Azure SONiC&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://www.juniper.net/documentation/en_US/crpd/topics/concept/understanding-crpd.html&#34;&gt;Juniper cRPD&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;http://docs.frrouting.org/en/latest/overview.html&#34;&gt;FRR&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In addition to native containerized NOSes, containerlab can launch traditional virtual-machine based routers using &lt;a href=&#34;https://containerlab.srlinux.dev/manual/vrnetlab/&#34;&gt;vrnetlab integration&lt;/a&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Nokia virtual SR OS (vSim/VSR)&lt;/li&gt;&lt;li&gt;Juniper vMX&lt;/li&gt;&lt;li&gt;Cisco IOS XRv&lt;/li&gt;&lt;li&gt;Arista vEOS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;And, of course, containerlab is perfectly capable of wiring up arbitrary linux containers which can host your network applications, virtual functions or simply be a test client. With all that, containerlab provides a single IaaC interface to manage labs which can span contain all the needed variants of nodes:&lt;/p&gt;&lt;div class=&#34;mxgraph&#34; style=&#34;max-width:100%;border:1px solid transparent;margin:0 auto; display:block;&#34; data-mxgraph=&#34;{&amp;quot;page&amp;quot;:1,&amp;quot;zoom&amp;quot;:1.5,&amp;quot;highlight&amp;quot;:&amp;quot;#0000ff&amp;quot;,&amp;quot;nav&amp;quot;:true,&amp;quot;check-visible-state&amp;quot;:true,&amp;quot;resize&amp;quot;:true,&amp;quot;url&amp;quot;:&amp;quot;https://raw.githubusercontent.com/srl-wim/container-lab/diagrams/index.md&amp;quot;}&#34;&gt;&lt;/div&gt;&lt;!-- more --&gt;&lt;h2&gt;The WHY&lt;/h2&gt;&lt;p&gt;As it often happens, &lt;a href=&#34;https://containerlab.srlinux.dev&#34;&gt;https://containerlab.srlinux.dev&lt;/a&gt; was created by engineers to address their needs.&lt;/p&gt;&lt;p&gt;In containerlab&#39;s case the need was simple - to be able to create networking topologies with containerized Network Operating Systems&lt;/p&gt;&lt;p&gt;As you might know, the off-the-shelf tools like docker-compose are not really fit-for-purpose of defining a multi-interfaced containers, therefore many of us created the bespoke bash scripts ruling a web of veth pairs between containers.&lt;/p&gt;&lt;p&gt;Containerlab solves this, and helps many other pain points you might have seen while running your labs.&lt;/p&gt;&lt;h2&gt;The WHAT&lt;/h2&gt;&lt;p&gt;Containerlab is what docker-compose would be if it was created with networking topologies in mind.&lt;/p&gt;&lt;p&gt;We use so-called &lt;code&gt;clab files&lt;/code&gt; to define a topology that is then deployed by containerlab anywhere, where docker runs without any 3rd party dependencies.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;p1&#34; src=&#34;https://pbs.twimg.com/media/Ex1F03XWUAE16Ws?format=jpg&amp;amp;name=4096x4096&#34;&gt;&lt;/p&gt;&lt;p&gt;The &lt;code&gt;clab file&lt;/code&gt; is a YAML in disguise, it offers a way to define your topology top-to-bottom.&lt;/p&gt;&lt;p&gt;Balancing between the simplicity, conventionality and expressiveness it allows users to define topologies that are both easy to read/write and yet are not limited in features)&lt;/p&gt;&lt;p&gt;```yamlname: srlceos01&lt;/p&gt;&lt;p&gt;topology: nodes: srl: kind: srl image: srlinux:20.6.3-145 license: license.key ceos: kind: ceos image: ceos:4.25.0F&lt;/p&gt;&lt;p&gt;links: - endpoints: [&#34;srl:e1-1&#34;, &#34;ceos:eth1&#34;]```&lt;/p&gt;&lt;h2&gt;The HOW&lt;/h2&gt;&lt;p&gt;This &lt;code&gt;clab file&lt;/code&gt; is all that is needed to spin up a lab of the two interconnected nodes - Nokia SR Linux and Arista cEOS.&lt;/p&gt;&lt;p&gt;Yes, that is all that&#39;s needed. No bulky emulators, no bespoke datapaths. A pure container-based lab powered by linux networking primitives.&lt;/p&gt;&lt;p&gt;That is what you get:&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;p2&#34; src=&#34;https://pbs.twimg.com/media/Ex1J3PRWgAEZyMc?format=jpg&amp;amp;name=4096x4096&#34;&gt;&lt;/p&gt;&lt;p&gt;All the heavy lifting of launching the containerized NOS is abstracted by containerlab kinds. It knows how to start SR Linux and cEOS. Just tell it which kind you need and what image to use&lt;/p&gt;&lt;p&gt;No need to keep handy those endless ENV vars or lengthy commands.&lt;/p&gt;&lt;p&gt;Interconnecting the nodes is as easy as writing a string of text.Tell containerlab which interfaces you want to be interconnected, and it will create the veth pairs blazingly fast.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;p3&#34; src=&#34;https://pbs.twimg.com/media/Ex1K9C6W8AIiEpI?format=jpg&amp;amp;name=4096x4096&#34;&gt;&lt;/p&gt;&lt;p&gt;And surely enough, that is just the tip of an iceberg, containerlab packs a ton of features which I won&#39;t repeat here, as they are all mentioned in the &lt;a href=&#34;https://containerlab.srlinux.dev/#features&#34;&gt;docs site&lt;/a&gt; we carefully maintain.&lt;/p&gt;&lt;h2&gt;Multivendor capabilities&lt;/h2&gt;&lt;h3&gt;Arista cEOS&lt;/h3&gt;&lt;p&gt;Although containerlab was born in Nokia, ...&lt;/p&gt;</description><link>https://netdevops.me/2021/containerlab-your-network-centric-labs-with-a-docker-ux/</link> <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2021/containerlab-your-network-centric-labs-with-a-docker-ux/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2021/containerlab-your-network-centric-labs-with-a-docker-ux/</guid> </item> <item> <title>Building and publishing deb/rpm packages with goreleaser and gemfury</title> <author>rdodin</author> <category>apt</category> <category>gemfury</category> <category>goreleaser</category> <category>yum</category> <description>&lt;h1&gt;Building and publishing deb/rpm packages with goreleaser and gemfury&lt;/h1&gt;&lt;p&gt;I am a huge fan of a &lt;a href=&#34;https://goreleaser.com/&#34;&gt;goreleaser&lt;/a&gt; tool that enables users to build Go projects and package/publish build artifacts in a fully automated and highly customizable way. We&#39;ve have been using goreleaser with all our recent projects and we couldn&#39;t be any happier since then.&lt;/p&gt;&lt;p&gt;But once the artifacts are built and published, the next important step is to make them easily installable. Especially if you provide deb/rpm packages which are built with &lt;a href=&#34;https://goreleaser.com/customization/nfpm/&#34;&gt;NFPM integration&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The &#34;challenge&#34; with deb/rpm packages comes to light when project owners want to add those packages to Apt/Yum repositories. Goreleaser doesn&#39;t provide any integrations with 3rd party repositories nor there are Apt/Yum repositories which are free and provide an API to upload artifacts. Or are there?&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;Gemfury aka Fury.io&lt;/h2&gt;&lt;p&gt;Actually there is at least one - the &lt;a href=&#34;https://gemfury.com/&#34;&gt;gemfury.io&lt;/a&gt; project that does just that (and even more).&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;fury&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/f329ec478f16c4b2c0dce0108a51be75/image.png&#34;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Gemfury is a private package repository to help you easily reuse code without worrying about its hosting or deployment. It integrates directly with existing package management tools that you already use.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Among other repositories, Fury provides a Yum/Apt repo for pre-built deb/rpm packages. It is free for public packages, which makes it a good choice for OSS projects. It also sports a hefty number of options to upload artifacts, from a simple &lt;code&gt;curl&lt;/code&gt; to a push via its own CLI tool.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;upload&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/9d85417c6db94401967e1a4e7d342354/image.png&#34;&gt;&lt;/p&gt;&lt;p&gt;Just register within the service and generate a &lt;a href=&#34;https://gemfury.com/help/tokens/#push-tokens-to-upload-packages&#34;&gt;push token&lt;/a&gt;, and you are good to go leveraging Goreleaser to push your artifacts to Fury.&lt;/p&gt;&lt;h2&gt;Using Goreleaser with Fury&lt;/h2&gt;&lt;h4&gt;Step 1: Adding Fury&#39; token&lt;/h4&gt;&lt;p&gt;Once you have a Fury&#39; push token, it is a matter of a few lines of code on the Goreleaser side.&lt;/p&gt;&lt;p&gt;I am using Goreleaser&#39; Github action to build and publish artifacts, therefore I added push token to repo&#39;s secrets and added it as another environment variable of a goreleaser action:&lt;/p&gt;&lt;p&gt;```yaml&lt;/p&gt;&lt;h1&gt;github action workflow file&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;name: Releaseon: push: tags: - v*jobs: goreleaser: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: fetch-depth: 0 - name: Set up Go uses: actions/setup-go@v2 with: go-version: 1.15 - name: Run GoReleaser uses: goreleaser/goreleaser-action@v2 with: version: v0.155.0 args: release --rm-dist env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} FURY_TOKEN: ${{ secrets.FURYPUSHTOKEN }}```&lt;/p&gt;&lt;p&gt;This will make our &lt;code&gt;FURYPUSHTOKEN&lt;/code&gt; secret value to be available inside the Goreleaser&#39; Env vars under the &lt;code&gt;FURY_TOKEN&lt;/code&gt; name.&lt;/p&gt;&lt;h4&gt;Step 2: Add ID for NFPM builds&lt;/h4&gt;&lt;p&gt;In the &lt;code&gt;nfpm&lt;/code&gt; section of your &lt;code&gt;.goreleaser.yml&lt;/code&gt; file add &lt;code&gt;id&lt;/code&gt; field. This identification string will be used in Step 3 to scope which artifacts will be pushed to Fury. Since Fury will be used exclusively for dep/rpm artifacts, by using the &lt;code&gt;id&lt;/code&gt; related to them we will skip artifacts which are generated in the &lt;code&gt;build&lt;/code&gt; section of goreleaser (aka archives).&lt;/p&gt;&lt;p&gt;```yaml&lt;/p&gt;&lt;h1&gt;.goreleaser.yml file&lt;/h1&gt;&lt;p&gt;&lt;SNIP&gt;nfpms: - id: packages # here we say that artifacts built with nfpm will be identified with &lt;code&gt;packages&lt;/code&gt; string. file_name_template: &#34;{{ .ProjectName }}&lt;em&gt;{{ .Version }}&lt;/em&gt;{{ .Os }}_{{ .Arch }}&#34;&lt;SNIP&gt;```&lt;/p&gt;&lt;h4&gt;Step 3: Add custom publisher&lt;/h4&gt;&lt;p&gt;Now we need to tell Goreleaser to actually push those deb/rpm files it produced to a Fury repo. This is easily done with the &lt;a href=&#34;https://goreleaser.com/customization/publishers/&#34;&gt;custom publishers&lt;/a&gt; feature.&lt;/p&gt;&lt;p&gt;&lt;code&gt;yamlpublishers: - name: fury.io # by specifying `packages` id here goreleaser will only use this publisher # with artifacts identified by this id ids: - packages dir: &#34;{{ dir .ArtifactPath }}&#34; cmd: curl -F package=@{{ .ArtifactName }} https://{{ .Env.FURY_TOKEN }}@push.fury.io/netdevops/&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Look how easy it is. Now on every goreleaser&#39; build, artifacts from nfpm will be concurrently uploaded to Fury and immediately available to the users of those Apt/Yum repositories. Do note, that by default pushed artifacts have a private scope, so don&#39;t forget to visit Fury&#39; account dashboard and make them public.&lt;/p&gt;&lt;p&gt;Did I say that Goreleaser is a great tool? I bet I did, so consider supporting it if you have a chance.&lt;/p&gt;</description><link>https://netdevops.me/2021/building-and-publishing-debrpm-packages-with-goreleaser-and-gemfury/</link> <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2021/building-and-publishing-debrpm-packages-with-goreleaser-and-gemfury/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2021/building-and-publishing-debrpm-packages-with-goreleaser-and-gemfury/</guid> </item> <item> <title>Transparently redirecting packets/frames between interfaces</title> <author>rdodin</author> <category>lacp</category> <category>ovs</category> <category>tc</category> <category>vrnetlab</category> <description>&lt;h1&gt;Transparently redirecting packets/frames between interfaces&lt;/h1&gt;&lt;p&gt;Lately I have been consumed by an idea of running container-based labs that span containerized NOSes, classical VM-based routers and regular containers with a single and uniform UX.&lt;/p&gt;&lt;p&gt;Luckily the foundation was already there. With &lt;a href=&#34;https://github.com/plajjan/vrnetlab&#34;&gt;plajjan/vrnetlab&lt;/a&gt; you get a toolchain that cleverly packages qemu-based VMs inside the container packaging, and with &lt;a href=&#34;https://github.com/networkop/docker-topo&#34;&gt;networkop/docker-topo&lt;/a&gt; you can run, deploy and wire containers in meshed topologies.&lt;/p&gt;&lt;p&gt;One particular thing though we needed to address, and it was the way we interconnect containers which host vrnetlab-created routers inside.&lt;/p&gt;&lt;p&gt;Vrnetlab uses its own &#34;overlay datapath&#34; to wire up containers by means of an additional &#34;vr-xcon&#34; container that stitches the exposed sockets. Although this approach allows to re-wire containers in different topologies after the start, this was not something that we could use if we wanted use non-vrnetlab containers in our topology. Ideally I wanted to emulate p2p links between the routers (running inside containers) by veth pairs stretched between them, pretty much like docker does when it launches containers. And that is also the way docker-topo works.&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;1 Linux bridge and &#34;you shall not pass&#34;&lt;/h2&gt;&lt;p&gt;Michael Kashin in his docker-topo project wanted to do the same, and he &lt;a href=&#34;https://github.com/plajjan/vrnetlab/pull/188&#34;&gt;proposed&lt;/a&gt; to add a new connection type to vrnetlab which used linux bridges inside vrnetlab containers, thus allowing to interconnected vrnetlab containers in a docker-way:&lt;/p&gt;&lt;p&gt;&lt;code&gt;docker create --name vmx --privileged vrnetlab/vr-vmx:17.2R1.13 --meshnetdocker network connect net1 vmxdocker network connect net2 vmxdocker network connect net3 vmx&lt;/code&gt;&lt;/p&gt;&lt;p&gt;In a nutshell, this is what was proposed by Michael:&lt;/p&gt;&lt;div class=&#34;mxgraph&#34; style=&#34;max-width:100%;border:1px solid transparent;margin:0 auto; display:block;&#34; data-mxgraph=&#34;{&amp;quot;page&amp;quot;:3,&amp;quot;zoom&amp;quot;:2,&amp;quot;highlight&amp;quot;:&amp;quot;#0000ff&amp;quot;,&amp;quot;nav&amp;quot;:true,&amp;quot;check-visible-state&amp;quot;:true,&amp;quot;resize&amp;quot;:true,&amp;quot;url&amp;quot;:&amp;quot;https://raw.githubusercontent.com/srl-wim/container-lab/diagrams/vrnetlab.drawio&amp;quot;}&#34;&gt;&lt;/div&gt;&lt;p&gt;The router VM sitting inside the container connects to container&#39; data interfaces &lt;code&gt;eth1+&lt;/code&gt; by the means of Linux bridges. This approach is the most straightforward one, it doesn&#39;t require any additional kernel modules, it is well-known and battle-tested and it has a native support in qemu/libvirt.&lt;/p&gt;&lt;p&gt;But the elephant in the room is a Linux bridge&#39; inability to pass certain Ethernet frames - specifically LACP and STP BPDUs. And apparently LACP support is something that is badly needed in nowadays labs, as people want to test/demo EVPN multihoming. So as easy as it gets, classical bridges can&#39;t satisfy the requirement of emulating a p2p link between data interfaces.&lt;/p&gt;&lt;p&gt;Off we go looking for alternatives.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;ADD: Apparently, there is a simple way to make LACP to pass over the linux bridge, another great person Vincent Bernard read the mailing list archives &lt;a href=&#34;https://twitter.com/vince2_/status/1363452081445740549&#34;&gt;and found out&lt;/a&gt; that you can only restrict the MAC_PAUSE frames and leave LACP be.&lt;br&gt;though tc solution is cleaner for the purpose of a point-to-point link.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;2 Macvtap&lt;/h2&gt;&lt;p&gt;Another approach that Michael tried when he was working on docker-topo was macvtap interface that looked promising on paper.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;macvtap1&#34; src=&#34;https://pbs.twimg.com/media/EuF4GgyXUAEZ3j5?format=jpg&#34;&gt;&lt;/p&gt;&lt;p&gt;And although&lt;/p&gt;&lt;ol&gt;&lt;li&gt;this approach required to mount the whole &lt;code&gt;/dev&lt;/code&gt; to a container namespace,&lt;/li&gt;&lt;li&gt;it had no qemu native support so we had to play with opening file descriptors&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;we still tried...&lt;/p&gt;&lt;p&gt;...and we failed.&lt;/p&gt;&lt;p&gt;Macvtaps in bridge mode worked, but they were not passing LACP still. No matter what we tried it became evident that path is a no go.&lt;/p&gt;&lt;h2&gt;3 Openvswitch&lt;/h2&gt;&lt;p&gt;Most of my colleagues use openvswitch bridges to interconnect classical libvirt/qemu VMs when they need to have support for LACP. With OvS all it takes is a single configuration command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;bashovs-vsctl set bridge $brname other-config:forward-bpdu=true&lt;/code&gt;&lt;/p&gt;&lt;div class=&#34;mxgraph&#34; style=&#34;max-width:100%;border:1px solid transparent;margin:0 auto; display:block;&#34; data-mxgraph=&#34;{&amp;quot;page&amp;quot;:4,&amp;quot;zoom&amp;quot;:2,&amp;quot;highlight&amp;quot;:&amp;quot;#0000ff&amp;quot;,&amp;quot;nav&amp;quot;:true,&amp;quot;check-visible-state&amp;quot;:true,&amp;quot;resize&amp;quot;:true,&amp;quot;url&amp;quot;:&amp;quot;https://raw.githubusercontent.com/srl-wim/container-lab/diagrams/vrnetlab.drawio&amp;quot;}&#34;&gt;&lt;/div&gt;&lt;p&gt;The reason I didn&#39;t want to start with OvS in the first place is that it is like using a sledge-hammer when all you need is to drive through a tiny nail. OvS is heavy in dependencies, it requires a kernel module and sometimes you simply can&#39;t install anything on the host where you want to run containers.&lt;/p&gt;&lt;p&gt;But with all other options exhausted, I decided to add this datapath option to [my fork](https://github.com/hellt/...&lt;/p&gt;</description><link>https://netdevops.me/2021/transparently-redirecting-packetsframes-between-interfaces/</link> <pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2021/transparently-redirecting-packetsframes-between-interfaces/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2021/transparently-redirecting-packetsframes-between-interfaces/</guid> </item> <item> <title>How to patch Ubuntu 20.04 Focal Fossa with UKSM?</title> <author>rdodin</author> <category>ubuntu</category> <category>uksm</category> <description>&lt;h1&gt;How to patch Ubuntu 20.04 Focal Fossa with UKSM?&lt;/h1&gt;&lt;p&gt;Running multiple VMs out of the same disk image is something we, network engineers, do quite often. A virtualized network usually consists of a few identical virtualized network elements that we interconnected with links making a topology.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;topo&#34; src=&#34;https://img-fotki.yandex.ru/get/6605/21639405.11c/0_86301_84e43902_orig.png&#34;&gt;&lt;/p&gt;&lt;p&gt;In the example above we have 7 virtualized routers in total, although we used only two VM images to create this topology (virtualized Nokia router and it&#39;s Juniper vMX counterpart). Each of this VMs require some memory to run, for the simplicity, lets say each VM requires 5GB of RAM.&lt;/p&gt;&lt;p&gt;So roughly, the above topology will claim 30-35GB of RAM in order to operate. Enriching the topology by adding more VMs of the same type will continue to push for more memory, thus running big topologies often becomes an exercise of hunting for RAM.&lt;/p&gt;&lt;p&gt;Luckily, there are technologies like Kernel Same Merging (KSM) and it&#39;s enhanced version Ultra-KSM (UKSM) that are able to lift the memory requirement for use cases like above. In a nutshell, they allow to merge mem pages of the same content, effectively reusing the same memory pages between virtual machines.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;!!!info &#34;from &lt;a href=&#34;https://www.usenix.org/system/files/conference/fast18/fast18-xia.pdf&#34;&gt;UKSM usenix paper&lt;/a&gt;&#34; Memory deduplication can reduce memory footprint by eliminating redundant pages. This is particularly true when similar OSes/applications/data are used across different VMs. Essentially, memory deduplication detects those redundant pages, and merges them by enabling transparent page sharing.&lt;/p&gt;&lt;p&gt;Although UKSM is not a silver bullet for every application and use case, it tends to be a very good fit for hypervisors used to run virtualized networking topologies. For that reason the EVE-NG network emulation platform embeds UKSM in their product.&lt;/p&gt;&lt;p&gt;So I decided to bring UKSM to my Ubuntu 20.04 VM that I use to launch virtualized routers and containers to witness the benefits/issues of having it.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;uksm&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/5ac1a3e597d26fbf94d18e7d898e6a7c/image.png&#34;&gt;&lt;/p&gt;&lt;p&gt;The results look promising. Running 6 VMs with a system memory footprint of one is a solid memory optimization, especially considering that performance penalty is something we can bare in a lab where we mostly play with control plane features.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/55317652924b2ad3d083cf6719b5cd1e/image.png&#34;&gt;&lt;img alt=&#34;uksm-compare&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/55317652924b2ad3d083cf6719b5cd1e/image.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Now if you want to bring UKSM to your hypervisor you will need to jump through some hoops, as UKSM is a kernel feature that is not available as a module. This means that you need to build a kernel with UKSM enabled, and that might be a barrier too high for some of you. It was for me, until I spent a night trying multiple things until it worked, so let me share with you the process and the outcomes so that you can rip the benefits without having all the trouble of trial-and-error routine.&lt;/p&gt;&lt;h4&gt;0 TL;DR&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Download UKSM patches&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Download kernel source&lt;/p&gt;&lt;/li&gt;&lt;li&gt;Apply UKSM patch&lt;/li&gt;&lt;li&gt;Build kernel&lt;/li&gt;&lt;li&gt;Install kernel&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;1 Get UKSM patches&lt;/h2&gt;&lt;p&gt;As mentioned above, UKSM is a kernel feature and the way it is distributed nowadays is via &lt;code&gt;patch&lt;/code&gt; files that are available in &lt;a href=&#34;https://github.com/dolohow/uksm&#34;&gt;this Github repo&lt;/a&gt;. So our first step is cloning this repo to get the patches for recent (4.x and 5.x) kernels. Easy start.&lt;/p&gt;&lt;h2&gt;2 Get the kernel source code&lt;/h2&gt;&lt;p&gt;As the UKSM patches need to be applied to a kernel source code, we need to get one. Here things can get a tad complicated.&lt;/p&gt;&lt;p&gt;There are many different kernels out there:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;vanilla Linux kernels blessed by Linus himself&lt;/li&gt;&lt;li&gt;distribution kernels (Debian, Ubuntu, Fedora, etc)&lt;/li&gt;&lt;li&gt;third party kernels with the best hacks&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The UKSM patches were created against the vanilla Linux kernel, but my Ubuntu VM runs a kernel that was produced by Ubuntu team.&lt;/p&gt;&lt;p&gt;```bash&lt;/p&gt;&lt;h1&gt;on Ubuntu 20.04&lt;/h1&gt;&lt;p&gt;uname -aLinux kernel-build 5.4.0-48-generic #52-Ubuntu SMP Thu Sep 10 10:58:49 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux```&lt;/p&gt;&lt;p&gt;Vanilla linux kernel uses X.Y.Z versioning. If anything is appended after X.Y.Z (like &lt;code&gt;-48-generic&lt;/code&gt;) in my case, it indicates that the kernel comes from a distributor (Ubuntu in my case).&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Things that didn&#39;t work:&lt;br&gt;1 At first I tried to download the original Linux kernel, but the build process failed without giving me a good explanation.&lt;br&gt;2 Download latest 5.4 kernel from Ubuntu - UKSM patch didn&#39;t apply, as the code has changed apparently&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;After multiple rinse-repeat iterations I found out that I can take the Ubuntu kernel &lt;code&gt;5.4.0-48.52&lt;/code&gt; as UKSM patch applies to it no problem and the build succeeds.&lt;/p&gt;&lt;p&gt;How did I get one? Oh, that is also something worth documenting, as the path to knowing it is paved with broken links and articles dated early 2000s. First, go [here](https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/fo...&lt;/p&gt;</description><link>https://netdevops.me/2021/how-to-patch-ubuntu-2004-focal-fossa-with-uksm/</link> <pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2021/how-to-patch-ubuntu-2004-focal-fossa-with-uksm/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2021/how-to-patch-ubuntu-2004-focal-fossa-with-uksm/</guid> </item> <item> <title>Remove binaries and big files from Git repo</title> <author>rdodin</author> <category>git</category> <description>&lt;h1&gt;Remove binaries and big files from Git repo&lt;/h1&gt;&lt;p&gt;You slice and dice your files in a Git repo like a pro and accidentally commit a binary file. It happened to you as well, don&#39;t pretend it didn&#39;t.&lt;br&gt;Sooner or later you recognizes this file shouldn&#39;t be there, it is clogging your Git repo for no reason. OK, you delete the file and commit. But the repo size doesn&#39;t get any smaller. Hm...&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;Indeed, next time you do &lt;code&gt;git clone&lt;/code&gt; you are wondering why your repo is still megabytes in size, while it has just some source code files?&lt;/p&gt;&lt;p&gt;The thing is, by just deleting the file from your working tree and committing this action you don&#39;t make things any better. This large file still sits somewhere in &lt;code&gt;.git&lt;/code&gt; directory waiting for you to rewind the history back and get it. The problem though is that you want this file gone for good.&lt;/p&gt;&lt;h3&gt;0 TLDR&lt;/h3&gt;&lt;p&gt;All the tags, branches are preserved with this procedure, although I do not guarantee that the workflow will work in your case. Do a backup always.&lt;/p&gt;&lt;p&gt;```bash&lt;/p&gt;&lt;h1&gt;clone a repo with --mirror flag and change into it&lt;/h1&gt;&lt;p&gt;git clone --mirror &lt;repo-url&gt;&lt;/p&gt;&lt;h1&gt;launch cleanup process&lt;/h1&gt;&lt;p&gt;git filter-repo --strip-blobs-bigger-than 3M&lt;/p&gt;&lt;h1&gt;run GC&lt;/h1&gt;&lt;p&gt;git reflog expire --expire=now --all &amp;amp;&amp;amp; git gc --prune=now --aggressive&lt;/p&gt;&lt;h1&gt;update the more&lt;/h1&gt;&lt;p&gt;git push```&lt;/p&gt;&lt;h3&gt;1 Show me big files&lt;/h3&gt;&lt;p&gt;To see if your repo holds those monster files you can leverage some Git commands, but I found &lt;a href=&#34;https://gist.github.com/malcolmgreaves/39e33e9b161916cb92ae0fdcfea91d64&#34;&gt;this self-contained python script&lt;/a&gt; quite a good fit for the purpose:&lt;/p&gt;&lt;p&gt;```bash‚ùØ ./lf.py -c 20Finding the 20 largest objects‚Ä¶Finding object paths‚Ä¶&lt;/p&gt;&lt;p&gt;All sizes in kB. The pack column is the compressed size of the object inside the pack file.&lt;/p&gt;&lt;p&gt;size pack hash path6769 6761 82d233ab6ff841f16bd17c2b5a6906ccdd8af8e5 rpm/tool-1.0.0.x86_64.rpm13439 6723 dbd32fc21381cf1e4cb0ba964f53aff1ebcc8547 bin/tool12437 6223 967237f169780b8660a771c6f478de1d93822157 bin/tool12413 6211 dfd93506fa17401cc996223337b8372bf921887e bin/tool11776 5917 f35577a72a2493b00c6e0520d1454d9fdaedb886 bin/tool5646 5638 66cc7eb29577bb84aaa682dd1eb694fde1d9e399 rpm/tool-1.0.0.x86_64.rpm5944 4073 360106b01776e4e7419ab414878d582747d7c945 bin/tool-test5333 3899 53ef404d20a09db9040696eeb5df5bebf10ecf52 bin/tool4985 3569 1d81eafd70736f568526b7e5221478b5b3e67c6d bin/tool4111 3224 acfd2077e642272c2ab09cbfaf435b4fc91ac012 bin/tool4018 3205 f331cec6b0e599dfbef7361c947a14beea7ce4c2 bin/tool3849 3111 8bb4fdaeccecf1ef0a91fc780c243cb89109597a bin/tool655 456 393dadfa6f5957f60a42287ed2c6e7ddcd5688cc bin/tool```&lt;/p&gt;&lt;p&gt;Nice and easy we get 20 largest files which I have no intention to keep and they make the size of the repo to be in 70MB range with compression. No good.&lt;/p&gt;&lt;h3&gt;2 Removing large files&lt;/h3&gt;&lt;h4&gt;2.1 Beware of consequences&lt;/h4&gt;&lt;p&gt;Now to the fun part, lets remove those files, making our repo fit again!&lt;/p&gt;&lt;p&gt;One problem, though, it&#39;s not that easy. First of all, this operation is very intrusive. As Git stores the commits in a graph fashion, you can&#39;t change some commit in the middle, without rewriting the commits after it.&lt;/p&gt;&lt;p&gt;So be prepared, that all the commits will eventually have new hashes. Evaluate the consequences and implications of it.&lt;/p&gt;&lt;h4&gt;2.2 Procedure&lt;/h4&gt;&lt;p&gt;If you start searching, you will find many workflows, dating back to early 2000s and Git 1.x. I tried them and I regret.Eventually I found the working combination that I tested on two of my repos and they worked flawlessly.&lt;/p&gt;&lt;h5&gt;2.2.1 Make a backup&lt;/h5&gt;&lt;p&gt;Do a backup of your original repo&lt;/p&gt;&lt;h5&gt;2.2.2 Clone a mirror&lt;/h5&gt;&lt;p&gt;Now clone the repo with a &lt;code&gt;--mirror&lt;/code&gt; option. That step is very important. You will have your repo cloned under &lt;code&gt;&amp;lt;repo-name&amp;gt;.git&lt;/code&gt; directory, but you won&#39;t see actual files, instead you will have the Git database of this repo.&lt;/p&gt;&lt;h5&gt;2.2.3 Install Git-filter-repo&lt;/h5&gt;&lt;p&gt;The actual tool that does the job is called &lt;a href=&#34;https://github.com/newren/git-filter-repo&#34;&gt;Git-filter-repo&lt;/a&gt;. It is a successor to &lt;em&gt;Git-filter-branch&lt;/em&gt; and &lt;em&gt;BFG Repo Cleaner&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;There is the &lt;a href=&#34;https://github.com/newren/git-filter-repo/blob/main/INSTALL.md&#34;&gt;Install&lt;/a&gt; document, but it is written somehow complex. The easy way to install for me was copying the &lt;a href=&#34;https://github.com/newren/git-filter-repo/blob/main/git-filter-repo&#34;&gt;raw script&lt;/a&gt; and copying it under the directory that &lt;code&gt;git --exec-path&lt;/code&gt; command outputs.&lt;/p&gt;&lt;h5&gt;2.2.4 Run the cleanup&lt;/h5&gt;&lt;p&gt;Then you can read about the options this script supports, for me I chose the easiest path possible -- delete every file that is bigger than X Megabytes. So I entered the directory that appeared after I did &lt;code&gt;git clone --mirror&lt;/code&gt; and executed the following command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;git filter-repo --strip-blobs-bigger-than 3M&lt;/code&gt;&lt;/p&gt;&lt;p&gt;For my no-so-big repo with 500 commits, it finished in under a second. It removed all the files bigger than 3Megs and re-wrote all the commits that were affected by that change.&lt;/p&gt;&lt;h5&gt;2.2.5 Garbage collect&lt;/h5&gt;&lt;p&gt;We are not done yet. Although the files were removed fo...&lt;/p&gt;</description><link>https://netdevops.me/2021/remove-binaries-and-big-files-from-git-repo/</link> <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2021/remove-binaries-and-big-files-from-git-repo/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2021/remove-binaries-and-big-files-from-git-repo/</guid> </item> <item> <title>Projectdocs</title> <author>rdodin</author> <category>documentation</category> <category>mkdocs-material</category> <description>&lt;h1&gt;Projectdocs&lt;/h1&gt;&lt;p&gt;I am a firm believer that documentation is an integral part of the project. A terse, twisted, incomplete or sometimes even missing documentation penalizes your projects success.At the same time clean, concise and comprehensive documentation is not only something worth being proud of, but an opening to a users&#39; appreciation and fame.&lt;/p&gt;&lt;p&gt;I am sharing the way I build, publish and host documentation sites for my projects via this live-example site - &lt;a href=&#34;https://projectdocs.netdevops.me&#34;&gt;projectdocs.netdevops.me&lt;/a&gt;&lt;/p&gt;</description><link>https://netdevops.me/2020/projectdocs/</link> <pubDate>Fri, 30 Oct 2020 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2020/projectdocs/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2020/projectdocs/</guid> </item> <item> <title>gNMIc got better with YANG-completions</title> <author>rdodin</author> <category>gnmi</category> <category>gnmic</category> <category>openconfig</category> <category>yang</category> <description>&lt;h1&gt;gNMIc got better with YANG-completions&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://gnmic.kmrd.dev&#34;&gt;&lt;code&gt;gnmic&lt;/code&gt;&lt;/a&gt; was the first opensource project that I&#39;ve been part of that got widely adopted. As the maintainers of a public project, Karim and I were wondering when would we get the first external contribution.&lt;/p&gt;&lt;p&gt;To our surprise, the very &lt;a href=&#34;https://github.com/karimra/gnmic/pull/136&#34;&gt;first external contribution&lt;/a&gt; laid out the foundation to one of the most exciting features of &lt;code&gt;gnmic&lt;/code&gt; - YANG-Completions.&lt;/p&gt;&lt;p&gt;I thought that the best way to describe what YANG-completions is showing you a quick demo augmented with some comments. This resulted in this twitter-series:&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;üíªFellow Network Automation engineers,&lt;br&gt;today is a special day for YANG-based automation as we release the &amp;quot;YANG-completions&amp;quot; feature with gnmic v0.4&lt;br&gt;&lt;br&gt;I have only 1m30s to convince you that it is a dream turned into reality (or a black magic üíÄ)&lt;a href=&#34;https://t.co/Nylyay1pl4&#34;&gt;https://t.co/Nylyay1pl4&lt;/a&gt; &lt;a href=&#34;https://t.co/IOnumRCOZi&#34;&gt;pic.twitter.com/IOnumRCOZi&lt;/a&gt;&lt;/p&gt;&amp;mdash; Roman Dodin (@ntdvps) &lt;a href=&#34;https://twitter.com/ntdvps/status/1318933113951715334?ref_src=twsrc%5Etfw&#34;&gt;October 21, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/center&gt;&lt;/p&gt;</description><link>https://netdevops.me/2020/gnmic-got-better-with-yang-completions/</link> <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2020/gnmic-got-better-with-yang-completions/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2020/gnmic-got-better-with-yang-completions/</guid> </item> <item> <title>Arista EOS gNMI Tutorial</title> <author>rdodin</author> <category>arista</category> <category>gnmi</category> <category>gnmic</category> <category>openconfig</category> <category>yang</category> <description>&lt;h1&gt;Arista EOS gNMI Tutorial&lt;/h1&gt;&lt;p&gt;We were pleasantly surprised by the way community appreciated &lt;a href=&#34;https://netdevops.me/2020/gnmic-gnmi-cli-client-and-collector/&#34;&gt;gNMIc&lt;/a&gt; release. Thank you üôè! That solidifies the fact that a well-formed, documented and easy to use gNMI tool was needed.&lt;/p&gt;&lt;p&gt;Now with gNMIc available to everybody its easy like never before to test gNMI implementation of different routing OSes. And in this post we will get our hands on &lt;strong&gt;Arista vEOS&lt;/strong&gt;.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;For this journey we pack:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;vEOS router (either physical or virtual)&lt;/li&gt;&lt;li&gt;gNMIc &lt;a href=&#34;https://gnmic.kmrd.dev/&#34;&gt;documentation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;and a &lt;a href=&#34;https://github.com/hellt/gnmi-map&#34;&gt;gNMI-map&lt;/a&gt; to navigate through the gNMI realm.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Arista vEOS-for-labs is freely distributed and you can download the vmdk image from the official &lt;a href=&#34;https://www.arista.com/en/support/software-download&#34;&gt;software portal&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;vEOS configuration&lt;/h2&gt;&lt;p&gt;Once your vEOS starts with a blank config (credentials: &lt;code&gt;admin&lt;/code&gt; and an empty pass) we ought to add a minimal config to it before gNMI fun starts:&lt;/p&gt;&lt;p&gt;&lt;code&gt;txtusername admin privilege 15 secret admin!interface Ethernet1 no switchport ip address 10.2.0.21/24!management api gnmi transport grpc default&lt;/code&gt;&lt;/p&gt;&lt;p&gt;With this config snippet we do a few things important from the gNMI standpoint:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;enabling password for &lt;code&gt;admin&lt;/code&gt; to authenticate with a router&lt;/li&gt;&lt;li&gt;configuring IP address for the &lt;code&gt;Ethernet1&lt;/code&gt; interface to let gNMIc reach the router&lt;/li&gt;&lt;li&gt;enabling &lt;code&gt;gnmi&lt;/code&gt; management interface with the default transport config&lt;/li&gt;&lt;li&gt;default transport doesn&#39;t enforce TLS usage and uses &lt;code&gt;6030&lt;/code&gt; port&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;That is all it takes to configure vEOS to start replying to our first gNMI RPCs, ridiculously easy!&lt;/p&gt;&lt;h2&gt;gNMI Capabilities&lt;/h2&gt;&lt;p&gt;With gNMIc &lt;a href=&#34;https://gnmic.kmrd.dev/install/&#34;&gt;installed&lt;/a&gt;, our first stop would be trying out the gNMI Capabilities RPC. The Capabilities RPC is quite instrumental as it uncovers which gNMI version the device runs, what models it is loaded with and which encoding it understands.&lt;/p&gt;&lt;p&gt;```bash&lt;/p&gt;&lt;h1&gt;6030 - the default gNMI port on vEOS&lt;/h1&gt;&lt;h1&gt;credentials are admin:admin&lt;/h1&gt;&lt;h1&gt;--insecure mode is used to not enforce the TLS transport&lt;/h1&gt;&lt;p&gt;$ gnmic -a 10.2.0.21:6030 -u admin -p admin --insecure capabilitiesgNMI version: 0.7.0supported models: - openconfig-rib-bgp, OpenConfig working group, 0.7.0 - arista-qos-augments, Arista Networks, Inc., - arista-srte-deviations, Arista Networks, Inc., &lt;/p&gt;&lt;p&gt;&lt;CLIPPED&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;openconfig-platform-linecard, OpenConfig working group, 0.1.1&lt;/li&gt;&lt;li&gt;openconfig-if-tunnel, OpenConfig working group, 0.1.1supported encodings:&lt;/li&gt;&lt;li&gt;JSON&lt;/li&gt;&lt;li&gt;JSON_IETF&lt;/li&gt;&lt;li&gt;ASCII```&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Judging by the output returned we see that&lt;/p&gt;&lt;ul&gt;&lt;li&gt;vEOS 4.24.1.1F in my lab runs the latest gNMI version 0.7.0&lt;/li&gt;&lt;li&gt;it is configured with both openconfig and native models&lt;/li&gt;&lt;li&gt;it supports two variants of JSON encoding with a useless ASCII&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Getting to know Arista YANG models&lt;/h2&gt;&lt;p&gt;Before we can dive into the rest RPCs of gNMI service we have to get to know the YANG models vEOS listed as supported in Capabilities response.&lt;/p&gt;&lt;p&gt;Arista publishes its YANG models in the &lt;a href=&#34;https://github.com/aristanetworks/yang&#34;&gt;aristanetworks/yang&lt;/a&gt; repo and by the looks of it it seems they are OpenConfig believers. For the vEOS 4.24.1.1F release that I am running the &lt;a href=&#34;https://github.com/aristanetworks/yang/tree/master/EOS-4.24.0F&#34;&gt;list of YANG&lt;/a&gt; models is definitely angled towards OpenConfig models with native YANG models marked as experimental.&lt;/p&gt;&lt;p&gt;Browsing the source OC YANG files in this repo is one way to understand the structure of the models, or we can use &lt;a href=&#34;https://github.com/hellt/pyang-docker&#34;&gt;pyang&lt;/a&gt; or &lt;a href=&#34;https://github.com/openconfig/goyang&#34;&gt;goyang&lt;/a&gt; to generate a tree view. Michael Kashin shows &lt;a href=&#34;https://github.com/networkop/acb-oc&#34;&gt;here&lt;/a&gt; how to use goyang to quickly generate tree views of Arista models.&lt;/p&gt;&lt;p&gt;Once we know the structure of the OC YANG models vEOS is equipped with we can finally get to more advanced RPCs fetching, setting and subscribing.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;If YANG transformation topic is hard on you, ping me in comments and I will expand on this.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;gNMI Get&lt;/h2&gt;&lt;p&gt;Now that we know which models our gear runs we can easily issue a gNMI Get RPC with &lt;a href=&#34;https://gnmic.kmrd.dev/cmd/get/&#34;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; command. Lets pretend that we would like to know the configured IP addresses on the vEOS. All it takes is to carefully walk through the OC model to the right leaf:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ gnmic -a 10.2.0.21:6030 -u admin -p admin --insecure get \ --path &#34;/interfaces/interface[name=*]/subinterfaces/subinterface[index=*]/ipv4/addresses/address/config/ip&#34;{ &#34;source&#34;: &#34;10.2.0.21:6030&#34;, &#34;time&#34;: &#34;1970-01-01T02:00:00+02:00&#34;, &#34;updates&#34;: [ { &#34;Path&#34;: &#34;/interfaces/interface[name=Ethernet1]/subinterfaces/subinterface[index=0]/ipv4/addresses/address[ip=10.2.0.21]/config/ip&#34;, &#34;values&#34;: { &#34;interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config/ip&#34;: &#34;10.2.0.21&#34; } } ]}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The returned output indicates that router has only one IPv4 address &lt;code&gt;10.2.0.21&lt;/code&gt; configured and it is contained within the `/interfaces/interf...&lt;/p&gt;</description><link>https://netdevops.me/2020/arista-eos-gnmi-tutorial/</link> <pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2020/arista-eos-gnmi-tutorial/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2020/arista-eos-gnmi-tutorial/</guid> </item> <item> <title>gNMIc - gNMI CLI client and collector</title> <author>rdodin</author> <category>gnmi</category> <category>gnmic</category> <category>go</category> <category>openconfig</category> <description>&lt;h1&gt;gNMIc - gNMI CLI client and collector&lt;/h1&gt;&lt;p&gt;Despite the fact that &lt;a href=&#34;https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md&#34;&gt;gNMI&lt;/a&gt; is defacto the go-to interface for a model-driven telemetry collection, we, as a community, had no gNMI tool that was easy to install, pleasure to use, documented and pre-built for common platforms. Until now.&lt;/p&gt;&lt;p&gt;I am excited to announce the public release of &lt;a href=&#34;https://gnmic.kmrd.dev/&#34;&gt;&lt;code&gt;gnmic&lt;/code&gt;&lt;/a&gt; - a CLI client and a collector that talks gNMI to your devices.&lt;/p&gt;&lt;p&gt;!!!tip &lt;strong&gt;October 2022:&lt;/strong&gt; &lt;a href=&#34;../2022/gnmic-openconfig.md&#34;&gt;gNMIc has joined Openconfig&lt;/a&gt;.&lt;/p&gt;&lt;!-- more --&gt;&lt;h3&gt;Problem statement&lt;/h3&gt;&lt;p&gt;I am not exaggerating, there is a shortage of open source gNMI clients one can find. And when I say gNMI clients I mean the CLI clients that allow you to invoke gNMI service RPCs.&lt;/p&gt;&lt;p&gt;Earlier this year I bragged about it, in hope that my google-foo is just broken and the community knows of a gNMI client that I could download and use right away without jumping through hoops:&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;So coming back to the OpenConfig/gNMI and what a hot mess it is when it comes to the tooling.&lt;br&gt;&lt;br&gt;You would probably think that there is a top-notch gNMI CLI (or even a shell) for you to query your routers like a pro.&lt;/p&gt;&amp;mdash; Roman Dodin (@ntdvps) &lt;a href=&#34;https://twitter.com/ntdvps/status/1229845496660922368?ref_src=twsrc%5Etfw&#34;&gt;February 18, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;But that was not my google-foo, unfortunately. For the sake of completeness allow me to summarize the landscape of gNMI clients in a pre-gnmic era:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/openconfig/gnmi&#34;&gt;OpenConfig gNMI CLI client&lt;/a&gt; - thats the google search top result one gets when looking for gNMI client. A reference implementation which lacks some essential features:&lt;ul&gt;&lt;li&gt;no documentation, no &lt;a href=&#34;https://github.com/openconfig/gnmi/issues/7&#34;&gt;usage examples&lt;/a&gt; - you really better know how to read Go code to understand how to use it.&lt;/li&gt;&lt;li&gt;Get requests will require you to &lt;a href=&#34;https://github.com/openconfig/gnmi/issues/67&#34;&gt;write in proto&lt;/a&gt; syntax instead of a simple &lt;code&gt;get&lt;/code&gt; command with a path.&lt;/li&gt;&lt;li&gt;additional options like Encoding, Models are not exposed via flags.&lt;/li&gt;&lt;li&gt;no ready-made binaries - you need to have a Go tool chain to build the tool.&lt;/li&gt;&lt;li&gt;no &lt;em&gt;insecure&lt;/em&gt; support - you can kiss goodbye your lab installations without PKI.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/google/gnxi&#34;&gt;Google gnxi&lt;/a&gt; - Googles gNxI tools that include gNMI, gNOI.&lt;ul&gt;&lt;li&gt;the gNMI RPCs are split to different CLI tools which is not convenient&lt;/li&gt;&lt;li&gt;a list of flags is all you got when it comes to documentation&lt;/li&gt;&lt;li&gt;no releases to download, Go toolchain is needed&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/cisco-ie/cisco-gnmi-python#cli-usage&#34;&gt;cisco-gnmi-python&lt;/a&gt; - a Cisco Innovative Edge project that is quite decent and complete, good job! But a few improvements could have been made:&lt;ul&gt;&lt;li&gt;client doesn&#39;t allow to use insecure gRPC transport, PKI is mandatory.&lt;/li&gt;&lt;li&gt;Set requests can&#39;t set values specified on the command line.&lt;/li&gt;&lt;li&gt;CLI structure is not consistent across the commands&lt;/li&gt;&lt;li&gt;No option exposed to set the Subscription mode.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/influxdata/telegraf&#34;&gt;Telegraf&lt;/a&gt; and &lt;a href=&#34;https://github.com/nokia/ansible-networking-collections/tree/master/grpc&#34;&gt;Ansible gNMI module&lt;/a&gt; are not qualified to be considered as CLI tools.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;What makes gNMI tool nice to use?&lt;/h3&gt;&lt;p&gt;Looking at this landscape, the following essential features a nice gNMI client should have come to mind:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;provide a clean and vendor independent interface to gNMI RPCs&lt;/li&gt;&lt;li&gt;expose all configuration options the gNMI RPCs have via flags or file-based configurations&lt;/li&gt;&lt;li&gt;allow multi-target operations: i.e. a subscription made to a number of the devices&lt;/li&gt;&lt;li&gt;implement both TLS enabled and non-secure transport&lt;/li&gt;&lt;li&gt;support different output formats (JSON, proto) and destinations (stdout, file, streaming/messaging buses)&lt;/li&gt;&lt;li&gt;be documented&lt;/li&gt;&lt;li&gt;provide an easy way to install the tool without requiring a dev toolchain to be present.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;With these essential features in mind we started to work on &lt;a href=&#34;https://gnmic.kmrd.dev/&#34;&gt;gnmic&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;gNMIc and its features&lt;/h3&gt;&lt;p align=center&gt;&lt;img src=https://gitlab.com/rdodin/pics/-/wikis/uploads/46e7d1631bd5569e9bf289be9dfa3812/gnmic-headline.svg?sanitize=true/&gt;&lt;/p&gt;&lt;p&gt;The work on &lt;code&gt;gnmic&lt;/code&gt; started with analysis of the existing tools shortcomings coupled with collecting requirements from our fellow engineers and our past user experience.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;For the &lt;code&gt;gnmic&lt;/code&gt; features run down go to our beautiful documentation portal - &lt;a href=&#34;https://gnmic.kmrd.dev&#34;&gt;https://gnmic.kmrd.dev&lt;/a&gt;. In this post I will go a bit deeper on some core features and design choices we made, so please refer to the documentation if you are looking for a basic usage or command reference guide.&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;Consistent command line interface&lt;/h4&gt;&lt;p&gt;It is easy to spot a CLI tool that got some love from its developers by looking at the way it is composed. Since most of the &lt;code&gt;gnmic&lt;/code&gt; users will ...&lt;/p&gt;</description><link>https://netdevops.me/2020/gnmic-gnmi-cli-client-and-collector/</link> <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2020/gnmic-gnmi-cli-client-and-collector/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2020/gnmic-gnmi-cli-client-and-collector/</guid> </item> <item> <title>NETCONF subtree filtering by example</title> <author>rdodin</author> <category>netconf</category> <description>&lt;h1&gt;NETCONF subtree filtering by example&lt;/h1&gt;&lt;p&gt;If you pick a random NetEng and ask them if they love NETCONF they would likely say &#34;Nah&#34;. The ~~hate-hate~~ love-hate kind of relationship with NETCONF mostly roots in its XML layer that one can&#39;t swap out. But if we set the XML-related challenges aside, it will become clear that NETCONF is a very well designed management interface with lots of capabilities. &lt;/p&gt;&lt;p&gt;In this topic we will touch on the NETCONF&#39;s subtree filtering capabilities.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;NETCONF&#39;s &lt;a href=&#34;https://www.rfcreader.com/#rfc6241&#34;&gt;RFC 6241&lt;/a&gt; defines two methods for filtering contents on the server (router) side:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://www.rfcreader.com/#rfc6241_line867&#34;&gt;Subtree filtering&lt;/a&gt; - mandatory for a NETCONF-enabled device to support&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://www.rfcreader.com/#rfc6241_line3008&#34;&gt;XPATH filtering&lt;/a&gt; - an optional capability&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Subtree filtering is powered by the following components:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Namespace Selection&lt;/li&gt;&lt;li&gt;Attribute Match Expressions&lt;/li&gt;&lt;li&gt;Containment Nodes&lt;/li&gt;&lt;li&gt;Selection Nodes&lt;/li&gt;&lt;li&gt;Content Match Nodes&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;They are very well explained in the RFC, so I won&#39;t bother with copy-pasting the definition and the rules these filtering components follow. Instead we will focus on the practical examples and put Selection and Content Match nodes to work in different scenarios.&lt;/p&gt;&lt;h3&gt;1 Selection nodes&lt;/h3&gt;&lt;p&gt;Selection node allow us to get a node and all its nested elements. Our simple examples will revolve around interactions with local users configuration on a Nokia SR OS which is modelled with the following YANG model:&lt;/p&gt;&lt;p&gt;&lt;code&gt;textmodule: nokia-conf +--rw configure +--rw system | +--rw security | | +--rw user-params | | +--rw local-user | | +--rw user* [user-name] | | +--rw user-name types-sros:named-item | | +--rw password types-sros:hashed-leaf | | +--rw access | | | +--rw console? boolean | | | +--rw ftp? boolean | | | +--rw snmp? boolean | | | +--rw netconf? boolean | | | +--rw grpc? boolean | | | +--rw li? boolean | | +--rw console +--rw member* -&amp;gt;../aaa/local-profiles‚Ä¶&lt;/code&gt;&lt;/p&gt;&lt;p&gt;If we want to filter all the configuration information related to the local users we could use Selection node &lt;code&gt;&amp;lt;local-user/&amp;gt;&lt;/code&gt; in our get-config RPC:&lt;/p&gt;&lt;p&gt;&lt;code&gt;xml&amp;lt;get-config&amp;gt; &amp;lt;source&amp;gt; &amp;lt;running /&amp;gt; &amp;lt;/source&amp;gt; &amp;lt;filter&amp;gt; &amp;lt;configure xmlns=&#34;urn:nokia.com:sros:ns:yang:sr:conf&#34;&amp;gt; &amp;lt;system&amp;gt; &amp;lt;security&amp;gt; &amp;lt;user-params&amp;gt; &amp;lt;local-user/&amp;gt; &amp;lt;!-- selection node --&amp;gt; &amp;lt;/user-params&amp;gt; &amp;lt;/security&amp;gt; &amp;lt;/system&amp;gt; &amp;lt;/configure&amp;gt; &amp;lt;/filter&amp;gt;&amp;lt;/get-config&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Hint #1: &lt;a href=&#34;https://netdevops.me/2020/nokia-yang-tree-and-path-browser/&#34;&gt;Nokia-yangtree&lt;/a&gt; is a beautiful way to explore Nokia YANG models.&lt;br&gt;Hint #2: I recommend &lt;a href=&#34;https://netdevops.me/2020/netconf-console-in-a-docker-container/&#34;&gt;netconf-console&lt;/a&gt; to talk NETCONF to your routers.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;If we translate this get-operation command to plain English it would sound like: &lt;em&gt;Dear router, can you please return everything you have under &lt;code&gt;local-user&lt;/code&gt; node in the running configuration datastore?&lt;/em&gt;&lt;br&gt;And that is what router replies back:&lt;/p&gt;&lt;p&gt;```xml&lt;rpc-reply xmlns:nc=&#34;urn:ietf:params:xml:ns:netconf:base:1.0&#34; xmlns=&#34;urn:ietf:params:xml:ns:netconf:base:1.0&#34; message-id=&#34;urn:uuid:f00ec433-17b3-4bcb-9d83-c3557794e56e&#34;&gt; &lt;data&gt; &lt;configure xmlns=&#34;urn:nokia.com:sros:ns:yang:sr:conf&#34;&gt; &lt;system&gt; &lt;security&gt; &lt;user-params&gt; &lt;local-user&gt; &lt;user&gt; &lt;user-name&gt;admin&lt;/user-name&gt; &lt;password&gt;$2y$10$Ro5MzyBZ18eVve/aTIYt..fSBbyJar11QGcQbixrVPfxLcpXeZ4eu&lt;/password&gt; &lt;access&gt; &lt;console&gt;true&lt;/console&gt; &lt;netconf&gt;true&lt;/netconf&gt; &lt;grpc&gt;true&lt;/grpc&gt; &lt;/access&gt; &lt;console&gt; &lt;member&gt;administrative&lt;/member&gt; &lt;/console&gt; &lt;/user&gt; &lt;user&gt; &lt;user-name&gt;roman&lt;/user-name&gt; &lt;password&gt;$2y$10$xkqn46jNHBUJWit446j2o.Yu3E9zWOg44yRGjRK2YjRZE4p5xFjmG&lt;/password&gt; &lt;access&gt; &lt;console&gt;true&lt;/console&gt; &lt;/access&gt; &lt;console&gt; &lt;member&gt;default&lt;/member&gt; &lt;/console&gt; &lt;/user&gt; &lt;/local-user&gt; &lt;/user-params&gt; ...&lt;/p&gt;</description><link>https://netdevops.me/2020/netconf-subtree-filtering-by-example/</link> <pubDate>Fri, 03 Jul 2020 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2020/netconf-subtree-filtering-by-example/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2020/netconf-subtree-filtering-by-example/</guid> </item> <item> <title>gNMI Map</title> <author>rdodin</author> <category>gnmi</category> <category>openconfig</category> <description>&lt;h1&gt;gNMI Map&lt;/h1&gt;&lt;p&gt;Lately I&#39;ve been involved in project that required quite a deep understanding of OpenConfig gRPC Network Management Interface (gNMI). Going over the &lt;a href=&#34;https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md&#34;&gt;gNMI specification&lt;/a&gt; multiple times made me realize that I can&#39;t fully build a mental map of all the messages and encapsulations without having a visual representation of it. So I&#39;ve made one, lets see what it has to offer.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/hellt/gnmi-map&#34;&gt;gNMI Map&lt;/a&gt; is essentially a visual guide to the &lt;a href=&#34;https://github.com/openconfig/gnmi/blob/d19cebf5e7be48e7a6fa9fbdff668d18ad87be9d/proto/gnmi/gnmi.proto#L44&#34;&gt;gNMI service&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/6cf03cf18ae6a9e69fc1360d6c8a0796/gnmi_0.7.0_map.pdf&#34;&gt;&lt;img alt=&#34;map&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/6a9d18f9cb2240656aad5d224aa757df/rsz_image.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;It lays out the protobuf data types that compose the gNMI service and provides the references to the relevant sections of the reference guide and code definitions. For example, if you wondered what are the messages the client sends when it needs to query the Capabilites of the remote gNMI target, you can easily zoom into the Capabilities RPC and identify all the messages and types involved in this RPC:&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/65d05f945796da5e2649c82286460b9f/image.png&#34;&gt;&lt;img alt=&#34;cap&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/65d05f945796da5e2649c82286460b9f/image.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The visual connectors help you unwrap the nested messages and collect the whole picture.&lt;/p&gt;&lt;p&gt;Moreover, each message and type &#34;card&#34;0 has a link to a relevant documentation piece of the reference along with the link to its definition in the &lt;code&gt;gnmi.proto&lt;/code&gt; file:&lt;/p&gt;&lt;p align=center&gt;&lt;img src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/61e7fa143e5898653c1edb9b42b936f3/image.png&#34; style=&#34;width:70%&#34; /&gt;&lt;/p&gt;&lt;p&gt;allowing you to quickly jump either to the explanation paragraph of the spec or dive into the proto definition code piece.&lt;/p&gt;&lt;p&gt;Currently the latest gNMI version (0.7.0.) has been &#34;mapped&#34;, my intention is to release another map when a new version of the gNMI will be available, keeping the old ones versioned. That will allow having a map for each release after 0.7.0.&lt;/p&gt;&lt;p&gt;The map comes in a PDF format and is stored at &lt;a href=&#34;https://github.com/hellt/gnmi-map&#34;&gt;hellt/gnmi-map&lt;/a&gt;, you can quickly access the latest version with a shortcut: &lt;a href=&#34;https://bit.ly/gnmi-map&#34;&gt;https://bit.ly/gnmi-map&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Happy mapping!&lt;/p&gt;</description><link>https://netdevops.me/2020/gnmi-map/</link> <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2020/gnmi-map/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2020/gnmi-map/</guid> </item> <item> <title>Using Wireshark remote capture with EVE-NG</title> <author>rdodin</author> <category>eve-ng</category> <category>wireshark</category> <description>&lt;h1&gt;Using Wireshark remote capture with EVE-NG&lt;/h1&gt;&lt;p&gt;The power of a packet capture is boundless... Sometimes its indeed a pcap that can save you nights of troubleshooting, so being able to get one quickly and easily is an ace up a neteng sleeve.&lt;br&gt;In this post I&#39;ll show you how I use Wireshark&#39;s remote capture ability to sniff on packets running in EVE-NG without being need to install any custom plugins or packages from EVE.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;EVE-NG provides some integration packs with wrappers around Wireshark&#39;s remote capture feature to make capturing a one-click task. The integration pack has all the needed software and some Duct tape to make it all work:&lt;/p&gt;&lt;p&gt;&lt;code&gt;plink 0.73 (for wireshark)all necessary wrappersIt will modify windows registry files for proper work&lt;/code&gt;&lt;/p&gt;&lt;p&gt;I would rather want to keep my registry untouched for a simple task like sniffing the packets from a remote location, therefore I always use Wireshark remote capture without installing any client packs from Eve. It feels more &#34;appropriate&#34;, though I wouldn&#39;t mind to install the pack in a VM that I don&#39;t care about much.&lt;/p&gt;&lt;p&gt;So, you are perfectly capable of sniffing on packets running in EVE by having Wireshark alone. Thats the procedure:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Install wireshark&lt;/li&gt;&lt;li&gt;In the EVE lab view grep the link name of an interface you want to capture from&lt;br&gt;&lt;img alt=&#34;pic&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/210dd1dc98ba25f1981c7e5d552afae0/image.png&#34;&gt;&lt;br&gt;&lt;strong&gt;2.1&lt;/strong&gt; right click on the device you want to capture from&lt;br&gt;&lt;strong&gt;2.2&lt;/strong&gt; select &#34;Capture&#34; menu&lt;br&gt;&lt;strong&gt;2.3&lt;/strong&gt; move mouse over the interface you want to capture from&lt;br&gt;&lt;strong&gt;2.4&lt;/strong&gt; get the interface name (&lt;code&gt;vunl0_1_0&lt;/code&gt; in my example)&lt;/li&gt;&lt;li&gt;Open Wireshark and choose remote capture in the list of the capture interfaces&lt;br&gt;&lt;img alt=&#34;pic2&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/72cbfcf02025615e5edb73ee04ff5f17/image.png&#34;&gt;&lt;/li&gt;&lt;li&gt;Enter the address of your EVE hypervisor (can use names of your systems from ssh_config) &lt;img alt=&#34;pic3&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/1bb17b52b8660bfb70bab1e148262d85/image.png&#34;&gt;&lt;/li&gt;&lt;li&gt;Type down the interface name you got in step 2 (the &lt;code&gt;capture filter&lt;/code&gt; statement generates automatically) &lt;img alt=&#34;pic4&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/cedfd848bac4305e946f2eccca0f2471/image.png&#34;&gt;&lt;/li&gt;&lt;li&gt;Start capturing!&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;It might look like a lot of manual steps from the first sight, but it takes actually 10 seconds, since you only need to memorize the link name and type it once in the wireshark interface.&lt;/p&gt;</description><link>https://netdevops.me/2020/using-wireshark-remote-capture-with-eve-ng/</link> <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2020/using-wireshark-remote-capture-with-eve-ng/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2020/using-wireshark-remote-capture-with-eve-ng/</guid> </item> <item> <title>Nokia YANG tree and Path Browser</title> <author>rdodin</author> <category>nokia</category> <category>sr os</category> <category>yang</category> <description>&lt;h1&gt;Nokia YANG tree and Path Browser&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Automation Is as Good as the Data Models&lt;/em&gt; is a chapter&#39;s name in the great book titled &lt;a href=&#34;https://www.amazon.com/Network-Programmability-YANG-Modeling-driven-Management/dp/0135180392&#34;&gt;&#34;Network Programmability With YANG&#34;&lt;/a&gt;. These days you won&#39;t bedazzle anyone by just providing the set of YANG models for the flagship network products. The models alone, albeit a great step forward, do not guarantee that programmability will start flourish.&lt;br&gt;The automation tools leveraging YANG is often a missing link and in this post I am talking about the &lt;a href=&#34;https://github.com/hellt/nokia-yangtree&#34;&gt;Nokia YANG tree and Path Browser&lt;/a&gt; tools which help both our internal automation squad and our customers to be more effective working with our YANG models.&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;1 Models for machines&lt;/h2&gt;&lt;p&gt;At Nokia we distribute the YANG models via our &lt;a href=&#34;https://github.com/nokia/7x50_YangModels&#34;&gt;nokia/7x50_YangModels&lt;/a&gt; repository. This enables us to allow users to simplify the way they get the models. The challenge with these models, or any models provided in &lt;code&gt;.yang&lt;/code&gt; format for that matter, is that its extremely hard for a naked eye to browse/evaluate these models when doing network automation. They are great for compilers, and not as much for us - automation engineers.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cpp// first lines of ietf-interfaces.yang modulemodule ietf-interfaces { yang-version 1.1; namespace &#34;urn:ietf:params:xml:ns:yang:ietf-interfaces&#34;; import ietf-yang-types { prefix yang; } revision 2018-02-20; container interfaces { description &#34;Interface parameters.&#34;; list interface { key &#34;name&#34;; leaf name { type string; } leaf description { type string; } leaf enabled { type boolean; default &#34;true&#34;; }&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Likely, browsing the &lt;a href=&#34;https://github.com/YangModels/yang/blob/master/standard/ietf/RFC/ietf-interfaces%402018-02-20.yang&#34;&gt;&lt;code&gt;ietf-interfaces.yang&lt;/code&gt;&lt;/a&gt; file won&#39;t make you sweat, yet it shouldn&#39;t led you to a false conclusion that YANG code representation is easy. The reality hits hard when YANG exposes its features such as &lt;code&gt;groupings&lt;/code&gt; and &lt;code&gt;uses&lt;/code&gt;, custom &lt;code&gt;typedefs&lt;/code&gt; and multiple &lt;code&gt;identityrefs&lt;/code&gt;, solid layer of &lt;code&gt;XPATH&lt;/code&gt; here and there, twisted &lt;code&gt;imports&lt;/code&gt; and a composition with dozens of &lt;code&gt;submodules&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;For example, our combined model for the configuration-only data (&lt;a href=&#34;https://raw.githubusercontent.com/nokia/7x50_YangModels/master/latest_sros_20.2/nokia-combined/nokia-conf-combined.yang&#34;&gt;nokia-conf-combined.yang&lt;/a&gt;) is 15MB in size and has 331000 lines. That is like the opposite of &lt;em&gt;easy&lt;/em&gt;. But why is it important to peer inside the models in the first place?&lt;/p&gt;&lt;h3&gt;1.1 Why browsing models is important?&lt;/h3&gt;&lt;p&gt;Truth is that every model driven (MD) interface you have in mind such as NETCONF, gNMI, RESTCONF operates on the data that is modelled in YANG. Thus every single operation you make with these interfaces eventually aligned with the underlying YANG model to access the data.&lt;/p&gt;&lt;p&gt;And unless your automation suite leverages some advanced orchestrator-provided abstractions or code generated classes, you literally &lt;strong&gt;need to look&lt;/strong&gt; at the YANG modules when using those management interfaces.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;NETCONF operations must have the XML envelopes created in conformance with the YANG model (&lt;a href=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/45fd09db73543f94f6937655db3f70ff/image.png&#34;&gt;example&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;gNMI paths are XPATH-like paths modelled after the underlying YANG model (&lt;a href=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/789429d8fec1d721e04d6024df5f883b/image.png&#34;&gt;example&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;RESTCONF URL embeds a model path as dictated by the YANG model (&lt;a href=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/1b9d45fd859ee7a66f382bab0f02621c/image.png&#34;&gt;example&lt;/a&gt;)&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;2 YANG representations&lt;/h2&gt;&lt;p&gt;Make no mistake: regardless of the interface you pick, you end browsing YANG models and as you can imagine, scrambling through the raw YANG model representation is not an easy task. Luckily, the better looking representations of the very same models exist.&lt;/p&gt;&lt;h3&gt;2.1 Tree&lt;/h3&gt;&lt;p&gt;The &lt;a href=&#34;https://tools.ietf.org/html/rfc8340&#34;&gt;RFC8340 YANG tree&lt;/a&gt; representation is the one you see everywhere in the documentation and blogs. By passing the same &lt;code&gt;ietf-interfaces.yang&lt;/code&gt; snippet through the &lt;code&gt;pyang&lt;/code&gt; tool we transform the module to a better looking tree-like view:&lt;/p&gt;&lt;p&gt;&lt;code&gt;txt+--rw interfaces | +--rw interface* [name] | +--rw name string | +--rw description? string | +--rw type identityref | +--rw enabled? boolean&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Compared to the &lt;code&gt;.yang&lt;/code&gt; raw view, the &lt;em&gt;tree&lt;/em&gt; makes it way easier to glance over the model and understand the parent-child relationships of the data entry nodes and their types.&lt;/p&gt;&lt;p&gt;Still, it has some serious UX drawbacks an engineer will face:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;the path information is missing.&lt;/strong&gt; By looking at a certain leaf/container/list of a tree you can&#39;t easily say what is the path of that element starting from the root?&lt;br&gt; Yet it is ve...&lt;/li&gt;&lt;/ul&gt;</description><link>https://netdevops.me/2020/nokia-yang-tree-and-path-browser/</link> <pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate><source url="https://netdevops.me/feed_rss_created.xml">Applying DevOps to networks</source><comments>https://netdevops.me/2020/nokia-yang-tree-and-path-browser/#__comments</comments><guid isPermaLink="true">https://netdevops.me/2020/nokia-yang-tree-and-path-browser/</guid> </item> </channel></rss>